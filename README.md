### 참고해볼만한 면접 질문들(by 대 황 경민)

[https://chipped-radiator-153.notion.site/cdf7503afbb04827bb45b216c7b2342d?pvs=4](https://www.notion.so/cdf7503afbb04827bb45b216c7b2342d?pvs=21)

### 전체적인 제안 사항

- 답변 내용을 작성할 때, 답변에 맞는 경험이 꼬리질문으로 들어올 수 있을 것 같습니다.
간단한 예시를 덧붙이거나 경험을 준비하면 더 좋지않을까요?

### 기술멘토님 추천문제

- 6월 12일 수요일 - 구현, 시뮬레이션
    
    [](https://www.acmicpc.net/problem/17144)
    
    [](https://www.acmicpc.net/problem/16236)
    
    [](https://www.acmicpc.net/problem/3190)
    

### 기술멘토님 추천 면접 질문

- 링크 목록
    
    [기술면접 CS 질문 모음 | Notion](https://devseopchan.notion.site/CS-aee34dad7a544b2898ac9ec17ff841a7)
    

### 프론트엔드 기술면접 문항 모범답안 링크

[36. 프론트엔드 성능최적화를 위한 방법이 있다면 말씀해주시고 그 중 프로젝트에서 활용한 경험이 있다면 설명해주세요.](https://www.notion.so/36-00556561fa15412db7797241d185cc35?pvs=21) 

### 

[이력서](https://www.notion.so/b95f550210a945448211f9a10c66a07b?pvs=21)

---

## 참고자료

[**SEO(검색엔진 최적화)**](https://www.notion.so/SEO-d6eed693b949452ea2be2fc34f2103ed?pvs=21)

---

1. 상태관리를 왜 할까요? 그리고 평소 state 관리는 어떻게 하시나요?
    
    ✅ **답변**

    - 방혜찬
        
        상태 관리를 통해 화면에 출력되는 데이터들이 변경되었을 때, 관련된 컴포넌트들이 리렌더링을 통해 업데이트될 수 있습니다.
        
        또 상태 관리를 통해 UI 가 어떻게 업데이트 되는지 쉽게 확인할 수 있습니다.
        
        각각의 state 들은 사용되는 범위에 맞게 모아서 관리했습니다.
        
        특정 컴포넌트에서만 사용하는 state 는 컴포넌트 코드의 상단에 모아서 관리합니다.
        
        한 페이지 에서만 사용되는 state 들은 커스텀 hook contextAPI 를 사용하여 공유했고, 서로 다른 페이지 간의 state 의 공유가 필요한 경우에는 Redux 를 사용해 관리했습니다.
        
    - 오경민
        
        리액트에서 상태가 변경되면 렌더링이 발생합니다. 상태 관리를 통해 애플리케이션의 데이터 흐름을 일관되게 유지하는 것이 중요하고, 여러 컴포넌트가 동일한 데이터에 접근하고 이를 업데이트할 때 유용합니다.
        저는 평소 간단한 컴포넌트의 로컬 상태를 관리할 땐 useState를 사용했으며, 여러 컴포넌트에서 동일한 상태가 필요한 경우 Redux 라이브러리를 활용해 중앙 저장소 방식으로 상태를 관리하였습니다.
        
    - 김섭찬
        
        상태 
        
    - **❓ 꼬리질문**
1. Redux가 무엇인가요, 왜 Redux를 사용하시나요?
    
    ✅ **답변**
    
    - 방혜찬 🔧
        
        모든 상태들의 관리를 하나의 Store 에서 공유하고 업데이트할 수 있는 기능을 제공해줍니다.
        
        어플리케이션이 복잡해질수록 컴포넌트들이 다양해지고, 다양한 컴포넌트들 간 상태 정보를  prop 을 통해 공유하는 것이 것이 복잡해지기 때문에 상태 관리를 한 위치에서 처리할 수 있다는 장점이 있습니다.
        
        Redux 는 이러한 관점에서 개발자들이 전 범위의 상태 정보를 직관적으로 공유하고 조작할 수 있는 전역 상태 관리 기능을 제공해주기 때문에 사용합니다.
        
        개인 프로젝트에서 사용한 openAPI 의 응답 데이터의 범위가 넓어서 3개의 페이지에 걸쳐서 사용해야 했는데, 이 때 Redux 를 활용해서 한번 가져온 데이터를 공유할 수 있었습니다.
        
    - 오경민
        
        리덕스는 상태관리를 위한 라이브러리 입니다. 부모-자식 컴포넌트간 데이터 전달을 위해 props를 사용하게 되는데 depth가 깊어질 수록 불필요한 컴포넌트에서도 상태를 관리하게 됩니다. 이 문제를 해결하기 위해 중앙 저장소 방식인 redux를 사용할 수 있습니다. Redux를 사용하면 상태를 중앙 저장소 방식으로 관리하여 애플리케이션의 복잡성을 줄이고, 예측 가능한 상태 관리를 할 수 있다는 장점이 있습니다.
        
    - 김섭찬
        
        
    - **❓ 꼬리질문**
2. Redux 말고 다른 전역 상태 관리 아는 것 하나와 차이점을 말해주세요
    
    ✅ **답변**
    
    - 방혜찬 🔧
        
        Recoil 는 Redux 와 차이점이 있는 전역 상태 관리 라이브러리입니다.
        
        Redux 와 다르게 Functional Component 에서만 사용이 가능한 context API 기반으로 구현된 라이브러리입니다.
        
        action, dispatch, reducer, store 등 다양한 개념을 알아야 하는 Redux 에 비해 Recoil 은 Atom 과 Seletor 정도만 알아도 get/set 형태의 전역 상태 관리 구현이 가능합니다.
        
        Redux 에서는 비동기 처리를 위해 redux-thunk 나 redux-saga 등의 미들웨어를 사용하지만, Recoil 에서는 내장된 Selector 를 활용해 비동기 처리가 가능합니다.
        
        제 개인 프로젝트에서도 Redux 에서 사용할 데이터를 openAPI 로 가져오기 위해 redux-saga 를 미들웨어로 사용했는데, 이에 따라 추가되는 코드가 길어져서 불편한 점이 있었습니다.
        
    - 오경민
        
        context api에 대해 말씀드리겠습니다.
        Context API는 리액트의 내장 API로 데이터를 전역적으로 관리할 수 있게 해줍니다. Redux와 같은 복잡한 기능은 없지만 간단한 전역 상태 관리에 적합하며, 사용법이 비교적 단순하고, 상태를 필요로 하는 컴포넌트에 데이터를 쉽게 전달할 수 있다는 특징이 있습니다.
        
    - 김섭찬
        
        
    - **❓ 꼬리질문**

🔥 **피드백(1~3)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | - 또박또박한 발음. 깔끔한 시선처리가 좋았습니다.
    - 질문에 대한 답과 그게 어떤 것인지에 대한 부가 설명이 아주 좋았습니다. 이로 인해 단순 블로그에서 답을 보고 외워서 대답하는게 아닌 실제 자기 경험에 빗대어 말하는 느낌이 들어서 좋았습니다.
     |  |
    | 개선사항 | - 면접 태도 (쓸데없는 움직임, 발음 부정확, 말하는 속도 등)는 아주 좋았습니다. 다만 (2번 질문) 특정 질문에 대한 답을 하실 때, 조금 불필요한 대답도 있어서 그 부분은 과감하게 생략하고 대답하시면 더 좋을 것 같습니다.
    ⇒ 불필요한 부분은, 현재 애플리케이션, 개발자 등 이러한 단어가 포함된 답변입니다. |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | - 발음이 좋아서 내용 설명과 전달이 잘 됐습니다.
    - 사용해보지 않은 불확실한 내용은 배제하고 사용해본 내용 위주로 설명한 점이 좋았습니다.
    ⇒ 3번 문제에서 다른 라이브러리를 언급하는 대신 React 에 내장된 ContextAPI 를 언급한 부분. 
    ⇒ 다만 이 부분은 면접관에 따라 느낌이 다를 수 있을 것 같습니다. |  |
    | 개선사항 | - 말하는 도중 몸의 흔들림이 많이 보였습니다.
    - 초반에 말하는 속도가 빨라서 설명이 너무 빠르게 지나갔습니다. |  |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
    

---

4. 버츄얼 돔과 리얼 돔의 차이를 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        Virtual DOM 과 DOM 의 가장 큰 차이는 UI 의 실제 업데이트 방식이라고 생각합니다.
        DOM 의 경우 사용자 인터랙션으로 DOM 에 변화가 발생하면 브라우저 렌더링 과정이 반복되기 때문에 전체 노드들이 처음부터 다시 그려지는 시간이 필요합니다.
        Virtual DOM 에서는 변화들이 발생하는 경우 모든 변화를 하나로 묶어서 한번의 업데이트를 실행시키기 때문에 연산 횟수와 메모리 측면에서 더 효율적입니다.
        
        Virtual DOM 의 객체는 DOM 객체와 비교했을 때 태그이름, 태그속성, 자식노드 같은 속성은 가지고 있지만 getElementById 같은 API 는 갖고 있지 않기 때문에 비교가 더욱 효율적이고 연산들은 실제 DOM 이 아니라 메모리 상에서 동작하기 때문에 훨씬 더 빠릅니다.
        
    - 오경민
        
        DOM은 HTML과 같은 웹 문서를 트리 구조로 표현한 인터페이스입니다. Virtual DOM은 실제 DOM을 메모리에 복사한 형태로 볼 수 있습니다. DOM은 업데이트가 발생할 때 마다 리플로우와 리페인트가 발생할 수 있어, 성능에 영향을 미칠 수 있지만 가상돔은 변경된 부분만 실제 돔과 비교하여 업데이트 하기 때문에 불필요한 업데이트를 줄일 수 있다는 장점을 가지고  있습니다.
        
    - 김섭찬
        
        가상 DOM은 React의 핵심 아이디어 중 하나로, 리얼 DOM과는 별도로 존재하는 가상 트리 구조입니다.
        
        이 가상 트리는 리얼DOM의 가벼운 복사본으로 생각할 수 있습니다.
        
        React 애플리케이션이 업데이트 되면, 먼저 가상 DOM에 이를 반영하고, 그 다음에 실제 DOM에 변경 사항을 적용합니다.
        
    - **❓ 꼬리질문**
        - 가상 돔 객체와 실제 돔 객체의 차이점이 뭘까요?
5. useRef에 대해 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        useRef 는 함수형 컴포넌트에서 2가지 목적으로 활용할 수 있는 hook 입니다.
        첫번째 목적은 저장 공간 기능입니다.
        useRef 는 컴포넌트의 라이프사이클이 유지되는 동안 값이 휘발되지 않게 유지해주는 저장 공간의 역할을 할 수 있습니다. useState 와의 차이점은 저장된 값의 업데이트가 일어나도 리렌더링은 일어나지 않는다는 점입니다.
        두번째는 DOM 요소의 선택자로서의 기능입니다.
        사용자와의 인터랙션을 통해서 상태 변화가 아닌 DOM 요소를 스타일링 하거나 이벤트를 발생시키는 등의 작업에 실제 DOM 객체의 API 대신 사용할 수 있는 선택자 기능을 제공해줍니다.
        
    - 오경민
        
        useRef는 저장공간 역할과 DOM 요소에 접근할 수 있는 역할을 가지고있습니다.
        저장공간같은 경우 state와 비슷한 역할을 하지만 state는 변경되면 리렌더링이 발생하는 반면, ref에 저장된 값은 렌더링이 발생하지 않기 때문에 렌더링으로 인해 내부 변수들이 초기화되는걸 막을 수 있습니다. 그리고 DOM 요소에 접근해야 하는 경우 일반적인 자바스크립트에서 querySelector 같은 함수를 사용하지만 리액트에서 어떤 특정 돔을 선택해야 하는 경우 useRef 훅을 사용합니다.
        
    - 김섭찬
        
        렌더링에 필요하지 않은 값을 참조할 수 있는 React Hook입니다.
        
        state와는 다르게 ref는 변경해도 리렌더링을 촉발하지 않습니다.
        
        즉, 컴포넌트의 시각적 출력에 영향을 미치지 않는 정보를 저장하는데 사용하기 적합합니다.
        
    - **❓ 꼬리질문**
        
        useRef 와 일반 변수의 차이점
        
6. useEffect의 실행 순서에 대해 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬 🔧
        
        useEffect 도 React 의 함수형 컴포넌트에서 사용하는 hook 인데, 컴포넌트의 라이프 사이클에 맞춰 코드를 실행시켜줄 때 사용합니다.
        기본적인 순서는 처음에 컴포넌트가 처음 렌더링 될 때 첫번째 파라미터로 작성해놓은 콜백 함수가 실행됩니다.
        이후에는 두번째 파라미터에 설정한 의존성 배열 내부의 참조값이 변할 때 마다 다시 콜백 함수가 실행됩니다.
        마지막으로 첫번째 파라미터로 작성한 함수에서 return 값으로 callback 함수를 작성하여 컴포넌트가 unmount 되는 시점에 실행할 cleanup 코드를 작성할 수 있습니다.
        
        *실행 순서에 대해 설명하라잖아… 왜못본거니*
        
        첫번째로 컴포넌트가 렌더링되고 화면이 그려지고 난 후 useEffect 에 첫번째 파라미터로 전달한 callback 함수가 실행됩니다.
        다음으로 두번째 파라미터로 전달한 의존성 배열을 체크하여 내부의 값이 변환된 경우, callback 함수를 다시 실행합니다.
        마지막으로 컴포넌트가 unmount 되기 전에 callback 함수의 return 값으로 설정한 callback 함수가 실행됩니다.
        
        ---
        
        라이프 사이클 메서드는 대표적인 3가지 시점의 전후를 기준으로 존재합니다
        마운트되기 전에는 constructor 메서드를 사용하여 컴포넌트의 state 를 초기화하고, 이벤트 핸들러를 바인딩합니다.
        이후 DOM 에 컴포넌트가 렌더된 후에는 componentDidMount 메서드로 데이터 요청 등의 네트워크 요청을 처리합니다.
        이후 변화로 인한 리렌더가 실행되면 DOM 이 업데이트 된 후에는 componentDidupdate 메서드를 사용하여 변화에 따른 네트워크 요청을 보내는 작업을 처리합니다.
        마지막으로 DOM 에서 컴포넌트가 제거되기 직전에는 componentWillUnmount 메서드를 사용하여 타이머와 네트워크 요청, 바인딩한 이벤트 핸들러 등을 제거합니다.
        
        클래스 컴포넌트의 **constructor** 에서  이벤트 핸들러 바인딩 시 함수 표현식 형태로 선언되지 않은 이벤트 핸들러에 this 를 바인딩 시켜줘야 핸들러 내부에서 컴포넌트의 this 를 사용할 수 있다.
        this.handleClick = this.handleClick.bind(this);
        constructor 가 아닌 **componentDidMount** 에서 setState 로 state 초기화가 가능하긴 한데, 이러면 render 가 두번 호출되어 성능이슈가 생길 수 있다.(사용자는 못봄)
        리렌더는 props 변화, state 변화, 강제 발동으로 발생가능.
        **componentDidUpdate** 에서 **이전 props, state, snapshot** 을 가져와 사용가능.
        **getDerivedStateFromProps** 는 mount, update 시점에서 render 메서드를 호출하기 직전에 호출되는데,  props에 state가 의존하는 아주 드문 경우에 사용합니다. 예를 들어, <Transition>와 같은 컴포넌트를 구현할 때 무엇을 움직이도록 만들지 결정하기 위해 이전과 현재의 자식 엘리먼트를 비교하는 경우 편리하게 사용할 수 있습니다.
        **shouldComponentUpdate** 는 업데이트 시점에서 getDerivedStateFromProps 메서드 보다 먼저 실행됩니다. state 또는 props의 변화를 렌더링에 적용할건지 true 혹은 false 를 적용해 결정할 수 있습니다. 기본값은 true 이고 forceUpdate 메서드로 강제 리렌더링 하는 경우 호출되지 않습니다.
        this.props, this.state 와 메서드 인자로 전달받은 nextProps, nextState 를 비교할 수 있습니다. 단순히 리렌더링을 막기위해 사용하면 안되고 성능 최적화를 위해 사용해야 합니다.
        https://ko.legacy.reactjs.org/docs/optimizing-performance.html
        그 외에도 에러바운더리 컴포넌트에서 **componentDidCatch** 메서드로 에러객체를 사용하거나 에러페이지를 렌더링할 수 있습니다.
        
    - 오경민
        
        useEffect의 실행순서는 크게 3가지로 나눌 수 있습니다.
        첫번째로 리액트에서 useEffect의 내용이 바로 실행되지 않고 컴포넌트가 렌더링되었을 때,화면을 먼저 그리는 과정을 거치게됩니다.
        두번째로 useEffect훅 내부의 콜백함수가 실행되며 마지막으로 useEffect훅의 두번째 매개변수인 의존성 배열을 체크하고 의존성 배열에 들어있는 값이 변경되면 리렌더링이 되고 useEffect훅에 담긴 내용이 다시 실행되는 방식입니다.
        
    - 김섭찬
        
        React는 필요할 때마다 useEffect의 설정 및 정리 기능을 호출하며, 이는 여러번 발생할 수 있습니다.
        
        우선 구성 요소가 페이지에 추가(마운트)되면 설정 코드가 실행됩니다.
        
        종속성이 변경된 구성 요소를 다시 렌더링 할 때마다, 정리 코드는 이전 소품과 상태로 실행됩니다. 그런 다음 설정 코드가 새 소품 및 상태로 실행됩니다.
        
    - **❓ 꼬리질문**
        
        useEffect 의존성 배열 사용하지 않고 함수를 쓴 것과 그냥 컴포넌트 내에 작성한 것의 차이점?
        
        useEffect 를 사용할 때 주의할 점을 알고계시나요?
        

🔥 **피드백(4~6)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | • 4번 질문 : 돔과 가상 돔의 특징에 대해서 설명 ⇒ 이후 장단점 비교 설명 플로우가 좋았습니다.
    • 5번 질문 : 저장공간과 DOM 요소 조작에 대한 설명이 간결하고 핵심적인 부분만 잘 설명해 주셔서 좋았습니다. | • 5번 질문 : 두괄식으로 목적 2가지 인식하기 좋음 |
    | 개선사항 | • 6번 질문 한정으로 구체적인 설명은 좋지만 조금 더 간략하게 설명해 주시면 더 좋을 것 같습니다. | (주관적)전반적인 내용이 길어 조금 루즈하게 느껴질 수도 있을 것 같습니다. |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 설명을 간추리면서도 명확하게 하려고한게 느껴져서 좋았습니다.
    
     | * 3개 질문 모두 두괄식으로 2가지 역할, 3가지 순서 등 핵심 키워드를 얘기한 이후 설명을 한 부분이 말씀하시는 내용을 이해하는데 좋았습니다.
    * 4번: 차이를 얘기할 때 장단점 비교를 하며 ‘질문 내용에 대한 이해를 했구나’라고 느껴짐 |
    | 개선사항 | 저번보다 좋아졌지만 설명이 조금 빨랐습니다.
    4번 질문 : 가상돔과 돔의 차이 설명 때 간추리는 와중에 문제의 핵심인 가상돔과 돔의 차이점은 조금 더 파고들어도 어필이 돼지 않았을까요? -주관적- |  |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 질문의 대답을 두괄식으로 잘 구성해서 좋았습니다.
    말의 속도, 발음이 아주 좋았습니다. | 차분하게 설명하시는게 굉장히 좋았습니다. 전체적인 면접 태도를 봤을 때, 이정도면 충분하다고 생각이 들 정도로 전체적인 밸런스가 좋았습니다.
    
    전체적인 문제에 대한 답변은 적절하게 핵심 내용을 담아서 잘 해주셨습니다. |
    | 개선사항 | 전체적으로 설명의 간소화는 좋지만 질문의 핵심에 해당하는 내용은 조금 더 풀어서 설명하면 좋을 것 같습니다.
     (핵심 설명이 부족하면 꼬리질문이 유발될 것 같습니다 -주관적- ) | • useRef에 대한 설명 중, 저장공간에 대한 부분만 말씀해주셨는데 DOM 요소를 조작하는 부분까지도 설명해 주셨으면 더 좋았을 것 같습니다.
    답변하신 내용 자체는 간략하고 핵심이 들어가 있어서 좋았습니다.
    
    만약 실제로 저장공간에 대해서만 답을 하신다면 면접관 입장에서 “이 사람이 useRef 훅을 잘 모르나?” 이런 생각을 하는 면접관이 있을 수 도 있을 것 같습니다. |
    

---

7. var, let, const의 차이에 대해 알려주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        세가지 모두 변수를 선언하는데 사용되는 키워드들이지만, 4가지 차이점이 존재합니다.
        첫번째는 스코프의 차이입니다.
        let 과 const 는 블록스코프에서 사용이 가능하지만 var 는 사용이 불가능합니다.
        두번째는 변수 재선언의 여부입니다.
        var 는 같은 스코프에서 같은 변수명으로 재선언이 가능하지만, let 과 const 는 불가능합니다.
        세번째는 변수 재할당의 여부입니다.
        var 와 let 은 변수 선언 후 참조값의 변경이 가능하지만, const 는 불가능합니다.
        마지막으로 호이스팅의 동작에 차이가 있습니다.
        var 는 선언 부분이 호이스팅 되지만, let 과 const 는 변수 스코프에서 선언되기 전까지 temporal deadzone 으로 취급되어 호이스팅이 되지 않는 것으로 취급합니다.
        
        ---
        
        (scope 란 데이터나 객체 레퍼런스, 표현식 등을 참조할 수 있는 현재의 실행 컨텍스트:execute context=context of execution 를 뜻한다. 만약 변수나 표현식:변수할당or계산식 이 현재 스코프에 안에 있지 않으면 사용이 불가능하다. 이런 scope 는 계층적인 구조여서 자식은 부모의 scope 에 접근 가능하지만 반대는 안된다.
        자바스크립트의 scope 에는 전역적으로 사용되는 글로벌 스코프와 스크립트 스코프, 함수 내부에서 사용되는 펑션 스코프, 중괄호로 묶은 코드블럭에서 사용되는 블록 스코프가 있습니다.)
        
    - 오경민
        
        var let const키워드 모두 변수를 선언할떄 사용하는 키워드입니다. var 키워드는 중복 선언과 재할당이 모두 가능한 특징을 가지고 있습니다. 이로 인해 예상치 못한 에러를 발생시킬 수 있어 사용을 지양하는 키워드 입니다.
        반면, let 과 const는 기존 var키워드의 문제를 해결하고자 나온 키워드 입니다. let같은 경우 중복 선언은 불가능 하지만, 재할당이 가능하며, const는 중복선언과 재할당 모두 불가능하다는 특징을 가지고 있습니다.
        
    - 김섭찬
        
        세 키워드의 차이점은 범위, 호이스팅, 중복선언이 있습니다.
        
        우선 범위의 경우
        Var로 선언된 변수는 함수 스코프를 가집니다. 함수 내부에서만 유효하고, 외부에서는 접근할 수 없습니다. If, for 등의 블록 스코프와는 무관합니다.
        
        반면 Let, const는 블록스코프를 가집니다.
        
        다음은 호이스팅입니다.
        var로 선언된 변수는 호이스팅되어 선언 부분이 코드의 상단으로 끌어올려집니다. 하지만, 실제 값의 할당은 코드가 실행될 때 이루어집니다.
        
        Let, const 변수 역시 호이스팅되지만 ’Temporal Dead Zone’(TDZ)에 걸려 선언 전에 접근하면 오류가 발생합니다.
        
        마지막은 중복선언입니다.
        var의 경우 스코프 내에서 동일한 이름으로 변수를 여러번 선언할 수 있습니다. Let, const의 경우 동일한 이름으로 다시 선언할 수 없습니다.
        
    - **❓ 꼬리질문**
8. Async/Await와 Promise의 차이에 대해 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬 🔧
        
        두가지 모두 비동기 작업을 처리하는데 사용되지만, 사용 방식에 차이가 있습니다.
        프로미스는 프로미스라는 객체에 비동기 작업에 관련된 코드를 콜백함수로 설정합니다. 그 코드 내부에서 비동기 작업의 성공/실패에 따른 결과를 resolve, reject 메서드로 설정할 수 있습니다. 그 후 then 과 catch 메서드로 실행 성공 여부에 따른 결과 처리를 설정할 수 있습니다. 이러한 사용 방식은 기존의 코드 작성방식과는 확연한 차이가 존재합니다.
        async await 는 이런 프로미스 객체를 동기형 코딩방식처럼 동작시킬 수 있어서 비동기 작업이 연달아 실행될수록 더 간단한 코드 구조를 가지게 됩니다. 프로미스 객체를 사용할 함수 선언문의 맨앞에 async 키워드를 붙여주고, 내부 코드에서 사용할 프로미스 객체 앞에 await 키워드만 붙여주면 비동기 처리 결과를 얻을 수 있습니다.
        이 때 비동기 처리에서 에러가 발생할 경우 try catch 구문으로 묶어서 처리해줄 수 있어서 에러 핸들링이 더 쉽습니다.
        
    - 오경민
        
        async/await 과 promise 모두 자바스크립트에서 비동기 처리를 위한 방법입니다.
        promise 같은 경우 성공, 실패, 대기 상태를 나타내는 객체입니다. then catch 메서드를 활용해 성공과 실패에 대한 로직을 처리합니다.
        async/await 같은 경우는 비동기 코드를 동기코드처럼 동작할 수 있게 해주는 역할을 합니다. async 가 선언된 함수 내에서 await 키워드를 사용하면 해당 비동기 작업이 완료되기 전까지 함수 실행이 일시적으로 중단되며, try catch 문을 활용해 예외처리를 더 깔끔하게 할 수있습니다.
        
    - 김섭찬
        
        Async/Await과 Promise는 JS에서 비동기 작업을 처리하기 위한 두 가지 방법입니다.
        
        Promise는 ‘then’과 ‘catch’를 사용하여 콜백 지옥을 피할 수 있지만, 복잡한 비동기 작업에서는 가독성이 떨어질 수 있습니다.
        
        Async/Await은 동기 코드처럼 작성할 수 있어 가독성이 좋고, 오류 처리를 위해 try/catch 블록을 사용할 수 있습니다. 이는 동기 코드의 에러 처리 방식과 유사합니다.
        
        Promise는 여러 비동기 작업을 처리할 때, Promise.all이나 Promise.race 등을 사용하여 흐름을 제어할 수 있습니다.
        
        Async/Await은 await 키워드를 사용하여 순차적으로 비동기 작업을 처리할 수 있습니다. 또한 [Promise.all과 함께 사용](https://youtu.be/RUfiNLo1CUI?si=Acdn4-F5rcxg72kt)할 수 있습니다.
        
    - **❓ 꼬리질문**
9. Arrow Function 이란 무엇인지 설명해주실 수 있을까요?
    
    ✅ **답변**
    
    - 방혜찬 🔧
        
        arrow function 은 2015년도에 도입된 ES6 에 추가된 함수 선언 방식입니다.
        arrow function 과 기존 함수의 가장 큰 차이점은 this 키워드의 동작 방식이라고 생각합니다.
        기존의 함수는 객체의 메서드로 호출했을 때 내부에서 사용하는 this 키워드는 객체에 접근하는 반면, arrow function 에서는 상위 요소의 스코프에 접근합니다.
        다른 차이점은 선언 형태입니다. 기존 함수와는 다르게 화살표 모양의 할당 키워드를 사용해서, 변수를 선언하듯이 함수를 선언할 수 있습니다.
        
    - 오경민
        
        arrow function은 es6문법에서 나온 새로운 함수 표현 방법입니다. 일반적인 함수 표현방식에서는 this 바인딩 문제가 있어, 이러한 문제 해결을 위해 arrow function이 나오게 되었습니다
        arrow function 같은 경우 this 를 바인딩하지 않기 때문에 arrow function 내부에서 this 를 사용하면 항상 상위 스코프의 this를 가리키게 됩니다. 이러한 특성때문에 자바스크립트에서의 this에 대한 혼동을 줄일수 있습니다. 또한 불필요한 함수 키워드나 중괄호 생략이 가능하기 때문에 가독성을 높여준다는 장점이 있습니다.
        
    - 김섭찬
        
        Arrow Function은 JS ES6에서 도입된 간결한 문법으로 함수를 정의하는 방법으로, 익명 함수와 콜백 함수를 작성할 때 유용합니다.
        
        기존의 함수와 다르게 파라미터가 하나만 있을 때 괄호를 생략할 수 있고, 함수 본문이 하나의 표현식이라면 중괄호와 return 키워드도 생략할 수 있습니다.
        
        그리고 Arrow Function은 this 바인딩, arguments 객체를 가지지 않아 상위 스코프의 this, argument 객체를 사용할 수 있습니다. 이를 통해, 콜백 함수에서 this를 일관되게 사용할 수 있습니다.
        
        반면 this 바인딩, prototype 속성이 없어, 객체 리터럴 메소드 정의, 생성자로 사용할 수 없습니다. 
        
    - **❓ 꼬리질문**

🔥 **피드백(7~9)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 전체적인 면접 태도는 좋았습니다. 이대로만 쭉 이어가시면 문제없을 것 같습니다.
    
    7번 질문 : 목적 → 스코프관점 → 각각의 차이에 대해 핵심 키워드를 다 포함하면서도 간결하게 대답을 해주셨습니다.
    
    8번 질문 : promise와 async/await의 목적이 무엇인지, promise 문제점이 무엇이고 왜 async/await 이 등장하게 되었는지도 간단명료하게 잘 설명해 주셨습니다.
    
    9번 질문 : 기존 함수들과 비교했을 때, 어떤 특징이 있고 장점이 무엇인지 잘 설명해 주셨습니다. |  |
    | 개선사항 | 확실히 지난 번 피드백 때 받으셨던, 약간 불필요한 설명들을 전부 개선하셨습니다. 오늘은 너무 듣기 편안했습니다. |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | - 이제 말하는 발음과 속도가 좋습니다!
    7번 문제
    - 답변을 설명할 때, 예시를 덧붙이는게 좋았습니다. |  |
    | 개선사항 | 7번 문제 설명하실 때 느낀점
    - 답변 내용에 여러개 항목이 있을 경우, 한꺼번에 설명하기보다 구조화해서 하나씩 순서대로 설명하면 더 좋을듯합니다. |  |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
    

---

10. ‘==’와 ‘===’ 연산자의 차이는 무엇인지 설명해주실 수 있을까요?
    
    ✅ **답변**
    
    - 방혜찬
        
        두가지 모두 값이 동등한지 확인하는 비교연산자이지만, 그 방식에 차이가 있습니다.
        == 는 피연산자들이 동일한지 비교할 때, 타입이 다르면 비교를 위해 타입 변환을 수행합니다.
        이 타입변환에는 자바스크립트 내에 몇가지 정해진 방식들이 있는데, 예를 들면 문자열과 숫자를 비교하기 위해서 먼저 문자열을 숫자로 변환한 후에 값을 비교합니다. 만약 숫자로 변환이 안되는 문자열이라면 변환 결과가 NaN 이 되기 때문에, 결과값이 false 로 고정됩니다.
        === 는 strict 한 비교를 위해 어떤 타입 변환도 수행하지 않습니다.
        따라서 피연산자들이 서로 다른 데이터 타입을 가지고 있으면 같지 않다고 판단합니다.
        타입이 같은 경우에는 몇가지 엣지 케이스만 제외하고는 모두 자기 자신과 동일한 값을 가진 경우만 동일하다고 판단합니다.
        
        (숫자의 2가지 엣지 케이스를 위한 문법:
        1. 부동소수점의 0 은 양과 음의 서로 다른 부호를 가질 수 있지만, +0 과 -0 의 경우 두가지를 동일한 값으로 판단한다.
        2. 잘못된 숫자값인 NaN 의 경우 NaN 끼리 비교해도 다르다고 판단한다.)
        
    - 오경민
        
        등호가 두 개 있는 경우 동등 연산자라 부르며 세 개 있는 경우 일치 연산자라고 부릅니다. 두 연산자 모두 값을 비교하는데 사용하는 연산자 이지만 약간의 차이점이 존재합니다.
        동등 연산자 같은 경우 두 연산자들의 자료형이 다르더라도 형 변환을 통해 공통된 타입으로 변경 후 값을 비교하게됩니다. 이러한 특성 때문에 생각지 못한 에러를 발생시킬 수 있습니다.
        일치 연산자는 형 변환이 발생하지 않고, 두 연산자 모두 값과 타입이 일치하는지를 비교하기 때문에 예측가능한 코드와 에러 방지를 위해 동등 연사자보단 일치 연산자를 사용하는게 더 좋다고 볼 수 있습니다.
        
    - 김섭찬
        
        
    - **❓ 꼬리질문**
        
        스트릭트 비교(===)에서의 엣지케이스에 대한 설명을 해주시겠어요?
        
11. 데이터 10,000개를 가지고 무한 스크롤 구현시에 가장 중요하게 고려해야 할점은 무엇인가요?
    
    ✅ **답변**
    
    - 방혜찬
        
        가장 중요한 것 하나만 꼽아야 한다면 성능의 최적화입니다.
        그 이유는 무한 스크롤이 유저의 사용자 경험을 향상시키기 위한 기능이라는 점입니다.
        성능의 최적화가 뒷받침 되지 않으면 오히려 개발 후에 사용자 경험이 악화되는 역효과가 발생합니다.
        또한 10000건 이라는 방대한 데이터를 보여줄 때는 그만큼 DOM 노드가 많아지게 되고, 과도한 렌더링에 따른 성능 저하가 일어날 수 있습니다.
        이러한 성능 저하를 방지하기 위해 데이터를 나눠서 불러오는 페이징 방식과, 현재 화면에 보이는 컨텐츠만 렌더링하고 나머지는 메모리에 보관하는 가상 스크롤을 활용해 DOM 노드를 줄이고 렌더링 성능을 향상시킬 수 있습니다.
        이외에도 디바운싱, 쓰로틀링을 활용해 스크롤 이벤트를 제한하거나 캐싱을 활용해 한번 조회한 데이터를 저장해놓고 다시 불러오는 최적화 작업도 가능합니다.
        (그 외 스크롤 감지, 로딩 상태 표시, 데이터 캐싱, 메모리 관리, 에러 핸들링, 접근성, SEO 최적화, 디자인 일관성
        참조 [https://velog.io/@theon2/데이터-10000개를-가지고-무한-스크롤-구현시에-가장-중요하게-고려해야-할점은](https://velog.io/@theon2/%EB%8D%B0%EC%9D%B4%ED%84%B0-10000%EA%B0%9C%EB%A5%BC-%EA%B0%80%EC%A7%80%EA%B3%A0-%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B5%AC%ED%98%84%EC%8B%9C%EC%97%90-%EA%B0%80%EC%9E%A5-%EC%A4%91%EC%9A%94%ED%95%98%EA%B2%8C-%EA%B3%A0%EB%A0%A4%ED%95%B4%EC%95%BC-%ED%95%A0%EC%A0%90%EC%9D%80)
        https://f-lab.kr/insight/implementing-infinite-scroll
        [https://velog.io/@eunoia/무한-스크롤Infinite-scroll-구현하기#무한-스크롤의-단점](https://velog.io/@eunoia/%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4Infinite-scroll-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0#%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4%EC%9D%98-%EB%8B%A8%EC%A0%90))
        
    - 오경민
        
        무한 스크롤 기능을 구현할 때, API 호출 최적화나 ux 적인 부분들을 고려해서 구현해야 한다고 생각합니다.
        예를들어, 스크롤 시 데이터를 100개씩 불러온다고 가정했을 때, 한번에 100개의 DOM 요소가 생성되게 되는데, 이러한 경우 메모리 누수가 발생할 수 있습니다. 이런 문제를 해결하기 위해 화면에 보이는 요소만 렌더링하고 나머지 요소들은 DOM에서 제거하는 가상화 기법을 사용해서 성능부분을 개선할 수 있다고 생각합니다.
        또한 백엔드와의 소통을 통해 필요한 데이터만 불러오고, 동일한 데이터 요청 방지를 위한 캐싱처리, 요청 실패에 대한 적절한 에러 핸들링을 통해 성능적인 부분과 ux적인 부분도 모두 고려해서 구현하면 더 좋을것 같다고 생각합니다.
        
    - 김섭찬
        
        
    - **❓ 꼬리질문**
        
        디바운싱, 쓰로틀링에 대해서 설명해주세요
        
12. JSX란 무엇인가요?
    
    ✅ **답변**
    
    - 방혜찬🔧
        
        JSX 는 React 에서 UI 개발의 편의성을 위해 개발된 일종의 확장 문법입니다.
        먼저 JS 는 HTML 처럼 문서와 데이터를 표기하기 위한 구조적인 언어가 아니고 프로그래밍 언어이기 때문에 UI 를 만들기 쉽지 않습니다.
        JSX 문법은 자바스크립트 코드 내에서 마크업 문법과 자바스크립트을 혼용하여 UI 컴포넌트를 정의할 수 있게 해줍니다. 때문에 UI 코드와 자바스크립트 로직 코드를 한 곳에 작성할 수 있어 코드의 가독성을 높일 수 있습니다.
        JSX 문법은 컴파일 타임에 변환이 되는데, 대표적으로 바벨 같은 컴파일러들이 JSX 로 작성된 UI 코드를 React 의 createElement 코드로 변환해주고, 이 코드가 런타임에 동작하여 실제 UI 가 생성됩니다.
        
    - 오경민
        
        JSX는 리액트에서 사용되는 문법입니다. 일반적으로 자바스크립트만 사용했을 때보다 jsx를 사용하면 ui 구조를 좀더 직관적으로 표현할 수 있기 때문에 가독성측면에서도 뛰어나다고 볼 수 있지만 jsx문법은 자바스크립트가 아니기 때문에 브라우저에서 직접 실행되지 않아 바벨과같은 트랜스파일러를 통해 자바스크립트 코드로 변환 후 실행되게 됩니다.
        
    - 김섭찬
        
        
    - **❓ 꼬리질문**
        
        바벨이란 무엇일까요?
        
        JSX 문법을 간단하게 설명해주세요
        
        바벨을 번들링했을 때 어느 경로로 파일이 저장되는지 알고 계신가요?
        

🔥 **피드백(10~12)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 각 질문에 대한 필요한 키워드를 넣어서 잘 설명해 주셨습니다. 꼬리질문이나, 예외 케이스, 그리고 자바스크립트에서 어떻게 동작하는지 설명이 아주 좋았습니다.  답변이 좋아 꼬리질문을 하기 좋아 보입니다. 이건 오히려 혜찬님께서 꼬리질문을 유도함으로써 면접을 유리하게 이끌어 갈 수 있는 장점이 될 수 있을 것 같습니다. | 10. JS내에서 타입 변환 방식의 설명이 적절했습니다.
    
    (주관적)전반적으로 꼬리 질문에 대한 답변이 잘 이루어져 질문 내용에 대한 이해도가 뛰어나다고 느껴졌습니다. |
    | 개선사항 | 꼬리질문에 대한 답변은 간략하고 핵심적인 부분만 말씀하시면 좋을 것 같습니다. | 12. Babel, 트랜스컴파일러에 대한 설명은 좀 더 핵심 내용만 요약한다면 좋을 것 같습니다.
    
    12. 번들링한 파일의 저장 경로에 대한 보충 설명
    트랜스파일링은 Babel이 실행하고, 번들링은 Webpack이 실행 
    번들링된 파일은 dist에 저장됨 |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 동작 원리와 그에 따른 주의점, 좋은점을 덧붙인게 좋았습니다. | 전반적인 답변의 내용이 핵심 키워드를 포함하고 있어 질문 내용에 대한 이해도를 충분히 확인할 수 있습니다. |
    | 개선사항 | 11번 문제에서
    문제에서 가장 ~한 게 뭐냐 라고 물어본 경우 여러개 중 먼저 하나를 강조하여 설명한 후에 나머지를 설명해주시면 더 좋을 것 같습니다. | 10. 각 연산자의 핵심 차이점만 간추려서 설명해주신다면 좋을 것 같습니다.
    
    (주관적)전반적인 설명을 핵심 키워드만 간추리고, 이후 꼬리 질문이 들어왔을 때 추가적으로 설명해도 좋을 것 같습니다. |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 최근에 했던 롤플레잉과 비교했을 때 간략한 내용에 훨씬 핵심이 많이 들어가서 전체적으로 좋았습니다. | 필요한 키워드를 통해 해당 질문에 대해 답을 잘 풀어주셨습니다. 너무 간략하지도, 너무 루즈하지도 않아서 이정도 답변 길이로 준비하시면 충분할 것 같습니다.
    하지만 꼬리질문이 충분히 나올수 있는 질문들 같은 경우는 그에 대한 대비도 충분히 하시는게 좋을 것 같습니다. |
    | 개선사항 | 12번 문제에서
    설명 대본에 개발자 적인 언어들을 활용했는데, 용어의 뜻이나 용어에 맞는 케이스를 완벽히 이해하고 말해야 꼬리 질문에 대응할 수 있을 것 같습니다.
    만약 이해가 어렵다면 쉬운 용어로 대체하는 것도 좋은 방법이라 생각합니다. | 개선사항은 아니지만, 만약 첫 질문에 대한 답변은 잘하고 꼬리질문에서 아무 대답도 못한다면 면접관에 따라 약간 신뢰성이 떨어질 수도 있을 것 같습니다. |
    

---

13. Javascript 의 호이스팅에 대해 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬🔧
        
        호이스팅이란 변수와 함수의 선언문들이 스코프의 최상단에서 먼저 실행되는 것을 말합니다. var 키워드로 변수를 선언하기 전에 변수를 출력하면 에러가 아닌 undefined 를 출력하게 됩니다.
        보통 변수 선언은 변수를 사용하기 전에 하는것이 일반적이기 때문에 이러한 호이스팅을 방지하기 위해 변수 선언에는 let, const 키워드를 사용합니다.
        let 과 const 키워드는 undefined 대신 reference error 가 발생합니다.
        함수의 경우에는 function 키워드로 선언하는 방식 대신 변수에 익명 함수를 대입하는 함수 표현식 형태를 사용합니다.
        (자바 스크립트의 호이스팅은 여러 언어들 중에서도 단연 이상한 동작방식을 가지고 있다.
        그 이유는 자바스크립트가 JIT(just in time) compiler 이기 때문이다.
        JIT compiler 에서는 코드가 한 줄마다 실행이 된다. 이러한 방식은 호이스팅을 비롯한 많은 특이한 문제점들을 발생시킨다.
        함수 표현식(function expression)은 var a = function(){ 코드 } 처럼 변수 선언형태로 함수를 저장할 경우, 뒤의 함수 코드는 초기화에 해당하기 때문에 a 라는 변수가 undefined 상태여서 이전 코드에서 함수 실행이 불가능합니다. - TypeError)
        
    - 오경민
        
        호이스팅은 변수나 함수를 선언했을때, 스코프 범위 최상단으로 끌어올려지는 현상을 의미합니다.
        
        var 키워드 같은 경우 선언과 초기화가 동시에 이루어지기 때문에 선언 이전에 참조를 하더라도 에러가 발생하지 않습니다.
        let과 const 키워드도 마찬가지로 호이스팅이 발생하지만,
        let키워드는 선언과 초기화 단계가 나뉘어져있고, 그 사이 TDZ가 존재합니다. 따라서 선언 전 참조할 경우 TDZ에 접근하게 되고 에러를 반환합니다. const 키워드는 선언과 초기화가 동시에 이루어지지만 그 전에 TDZ가 생성되어 마찬가지로 접근시 에러를 반환하게 됩니다.
        
        호이스팅이 선언문 자체를 상단으로 끌어올리는 걸 의미하기 때문에 변수와 마찬가지로 함수 선언식도 호이스팅이 발생하고, 선언 전에 참조하더라도 에러가 발생하지 않습니다.
        
    - 김섭찬
        
        호이스팅은 JS의 코드 실행 방식에서  코드 생성단계에 JS엔진이 코드의 스코프를 설정하고, 변수 및 함수 선언을 스코프의 최상단으로 끌어올리는 현상을 말합니다.
        이 과정에서 각 스코프 내의 모든 변수 선언과 함수 선언을 등록합니다.
        변수는 ‘undefined’로 초기화되며, 함수는 실제 함수 정의로 초기화됩니다.
        이를 통해 변수와 함수 선언이 어디에서든지 코드 실행 전에 인식될 수 있게 됩니다.
        이러한 동작 방식은 스코프와 관련된 버그를 예방하고, 코드의 가독성을 높여줍니다.
        
    - 이지혜
        
        호이스팅 : 변수와 함수의 선언이 해당 범위, 스코프의 최상단으로 끌어올려지는 것을 말합니다. 중요한 점은 선언만 끌어올려지고 초기화나 할당은 끌어올려지지 않기 때문에 초기화 전에 호출할 경우 undefind가 출력됩니다.
        
        Let과 const도 호이스팅 되지만 TDZ에 의해 보호되어 초기화 전에 접근할 수 없습니다.
        
        TDZ란 : 선언된 변수가 초기화 되기 전까지의 구간으로, TDZ내에 변수에 접근하면 레퍼런스 에러가 발생합니다.
        
        var는 함수스코프 / let, const는 블록스코프
        
    - **❓ 꼬리질문**
        
        let, const 의 차이점? (호이스팅에 관련된 내용을 설명하기)
        
        TDZ 가 무엇일까요?
        
        함수 선언의 방지
        
14. 동기와 비동기의 차이에 대해 설명해주시고 비동기 프로그래밍의 필요성에 대해 답변해주세요.
    
    ✅ **답변**
    
    - 방혜찬🔧
        
        프로그래밍에서 동기는 코드를 순서대로 한번에 한줄씩 실행시키는 방식을 뜻하고, 비동기는 여러 코드를 동시에 실행시킬 수 있는 방식을 뜻합니다.
        자바스크립트는 기본적으로 동기 방식을 사용하는데 여기에는 치명적인 단점이 존재합니다.
        현재 실행중인 코드가 완료되어야 다음 코드를 실행할 수 있는데, 실행 시간이 길어지는 경우, 유저가 페이지 내에서 다른 작업을 할 수 없다는 점입니다.
        이 문제를 해결하기 위해서 비동기적으로 실행될 콜백 함수를 사용하는 방식을 사용했고, 이후에 등장한 Promise 와 async await 를 통해 좀 더 간결하게 비동기처리를 할 수 있게 되었습니다. 
        
        (싱글 쓰레드 - 프로그램의 코드를 실제로 실행시키는 환경. 프로세스 - 쓰레드+자원+데이터. web api는 프로미스 기반 비동기들 있음, ES6 부터는 비동기 연산의 상태를 나타내는 프로미스 객체를 사용 가능 - pending, fulfilled, rejected 상태를 가진다. 성공 실패 여부에 따라 .then 과 .catch 의 체이닝을 통해 간결한 형태의 비동기 처리가 가능하다. ES8 부터는 async await 를 사용해 동기적인 코드 구조에서 비동기 처리가 완료될 때 까지 이후 코드의 실행을 일시중지할 수 있다. 이러한 특징 때문에 비동기 작업들을 실행할 때 순차적으로 실행될 필요가 없으면 async await 대신 Promise.All 을 사용하는 것이 바람직하다. async await 는 실행완료까지 대기가 필요한 Promise 앞에 await 키워드를 붙이고, 코드가 실행될 함수의 선언부에 async 키워드를 붙여서 사용한다. 단 에러처리는 try catch 구문을 통해 처리해야한다.)
        **(내 경험 강조)**
        
    - 오경민
        
        동기는 순차적으로 실행되는 것을 의미합니다. 진행 중인 작업이 끝나야 다음 작업으로 넘어갈 수 있습니다. 동기적인 코드는 직관적일 수 있지만, 작업 속도가 느리거나, 블로킹된다면 프로그램 성능에 영향을 미칠 수 있습니다.
        
        비동기는 작업이 병렬 처리되는 것을 의미합니다. 현재 진행 중인 작업이 끝나지 않았더라도 다음 작업을 미리 실행할 수 있습니다. 비동기는 주로 네트워크 요청이나 시간이 오래 걸리는 작업에 사용됩니다. 비동기는 일반적으로 프로그램 성능을 향상시키고 블로킹을 피할 수 있습니다.
        
        비동기 프로그래밍이 필요한 이유를 몇 가지 간단하게 말씀드려보겠습니다.
        우선 첫 번째는 성능 향상부분입니다. 비동기를 활용하면 속도가 느린작업이 다른 작업을 차단하지 않고 병렬처리되기 때문에 전체적인 성능이 향상된다고 볼 수 있습니다.
        두번째는 ux적인 부분 향상인데요, 사용자가 인터페이스를 사용할 때, 블로킹되지않고 계속 반응되기 때문에 ux향상 측면에서도 좋다고 볼 수 있습니다.
        세번째는 컴퓨ㅜ터 자원을 효율적으로 사용할 수 있다는 점입니다.
        cpu나 메모리를 효율적으로 활용할 수 있어서 대용량 데이터 처리나 많은 클라이언트 요청을 처리해야하는 서버에도 유용하게 활용할 수 있습니다.
        
    - 김섭찬
        
        동기 프로그래밍은 순차적으로 작업을 처리합니다. 즉, 하나의 작업이 완료될 때까지 다음 작업이 시작되지 않습니다.
        반면, 비동기 프로그래밍은 여러 작업이 동시에 실행될 수 있습니다.
        즉, 하나의 작업이 완료되기를 기다리지 않고 다음 작업을 실행합니다.
        
        비동기 프로그래밍은 긴 작업동안 프로그램이 응답성을 유지할 수 있게 합니다.
        I/O 작업이나 네트워크 요청과 같은 시간이 오래 걸리는 작업을 기다리는 동안 CPU가 다른 작업을 수행할 수 있어 자원을 효율적으로 사용할 수 있습니다.
        또한 여러 작업을 동시에 실행할 수 있어, 전체 처리 시간을 줄일 수 있습니다. 이는 특히 서버 프로그래밍에서 중요합니다.
        마지막으로 UI가 중단없이 작동하기 때문에, 사용자 경험을 향상시킬 수 있습니다.
        이러한 장점으로 인해 비동기 프로그래밍이 필요합니다.
        
    - 이지혜
        
        동기는 함수 A,B가 있다면 A가 모두 완료된 후에 B가 실행되는 직렬 방식이며
        비동기는 함수 A,B가 동시에 실행되어 병렬적으로 작업을 처리합니다.
        비동기 프로그래밍이 필요한 이유는 여러 작업을 동시에 처리할 수 있기 때문에 “””자원을 효율적””””으로 사용할 수 있으며,
        긴 작업이 실행되더라도 다른 작업을 할 수 있기 때문에 사용자 경험이 좋아집니다.
        자바스크립트에서는 콜백과 프로미스, async/await를 사용하여 비동기 프로그램을 구현할 수 있습니다.
        
        자원을 효율적 : 대용량 처리나 많은 클라이턴트 요청 처리
        
        프로미스, async/await : 체이닝을 간결하게 하고 / 비동기 작업을 동기프로그래밍 처럼 작성할 수 있다
        싱글스레드지만 이벤트 루프를 사용해서 비동기적으로 사용할 수 있음
        
    - **❓ 꼬리질문**
        
        비동기 프로그래밍이 필요한 경우의 예시를 들어주세요
        
        UX 부분에서 비동기를 처리했던 경험이 있나요?
        
        useEffect와 같은 react 훅에서 비동기 처리를 했던 경험이 있나요?
        
        Promise 와 setTimeout 을 0초로 설정한 코드 중 무엇이 먼저 실행될까요?
        
15. 브라우저의 작동 방식에 대해서 설명해주세요
    - 참고자료
        
        https://d2.naver.com/helloworld/59361
        
    
    ✅ **답변**
    
    - 방혜찬🔧
        
        웹사이트에 접속하는 예시를 통해 순서대로 설명해보겠습니다.
        첫번째로 유저가 웹사이트 주소를 입력했을 때, 브라우저는 DNS 조회를 통해서 실제 서버의 IP 주소를 찾고, TCP 로 연결을 설정한 후 HTTP 요청을 보내 응답을 받아옵니다.
        두번째로 응답 데이터를 분석하여 DOM 과 CSSOM 을 생성합니다.
        세번째로는 렌더 트리라는 것을 만들고, 이를 기반으로 각 노드를 보여주기 위한 위치와 크기를 계산하는 레이아웃 작업을 수행하고 페인팅 작업을 통해 레이아웃 트리의 요소들을 실제 브라우저 화면에 그려줍니다.
        마지막으로 온로드 자바스크립트 코드가 실행되면 유저가 상호작용할 수 있는 상태가 됩니다.
        (TCP - 연결 설정은 3way handshake - SYN/SYN-ACK/ACK, 연결 종료는 4way handshake - FIN/ACK-FIN/ACK 레이아웃 - 렌더 트리에 있는 모든 노드의 너비, 높이, 위치를 결정, DOM - HTML 문서의 내용을 담은 객체, CSSOM - 스타일 정보를 담은 객체)
        
    - 오경민
        
        사용자가 브라우저에 접속하면 웹 브라우저 엔진은 html, css 를 다운받아 각각 DOM, CSSOM 을 생성합니다.  생성된 DOM CSSOM을 결합하여 렌더트리를 형성하고, 렌더 트리를 기반으로 각 요소들의 위치나 크기를 계산해서 레이아웃을 그리고, 각각의 요소에 스타일을 적용한 뒤 최종적으로 사용자가 보는 브라우저가  만들어 집니다.
        
    - 김섭찬
        
        브라우저의 작동 방식은 사용자가 웹 페이지를 요청하고 해당 페이지를 화면에 표시하는 과정입니다.
        URL 입력에서 시작해, DNS 조회, 서버와의 연결, HTTP 요청 및 응답, 렌더링 엔진을 통한 페이지 생성, JavaScript 실행, 그리고 사용자 인터랙션 처리로 이어집니다.
        그리고 브라우저가 이 과정을 통해 사용자가 웹 페이지를 보고, 동작할 수 있도록 합니다.
        
    - 이지혜
        1. **URL 요청:** 사용자가 URL을 입력하면 브라우저는 HTTP 요청을 서버에 보냅니다.
        2. **서버 응답:** 서버가 HTML, CSS, JavaScript 파일 등을 브라우저에 응답합니다.
        3. **HTML 파싱:** 브라우저는 HTML을 파싱하여 DOM 트리를 만듭니다.
        4. **CSS 파싱:** CSS를 파싱하여 CSSOM 트리를 생성합니다.
        5. **DOM과 CSSOM 결합:** DOM과 CSSOM을 결합하여 렌더 트리를 만듭니다.
        6. **레이아웃 계산:** 각 요소의 위치와 크기를 계산합니다.
        7. **페인팅:** 계산된 레이아웃을 픽셀로 변환하여 화면에 그립니다.
        8. **JavaScript 실행:** JavaScript 코드를 실행하여 DOM을 조작하거나 스타일을 변경합니다.
    - **❓ 꼬리질문**
        
        Reflow와 Repaint 가 무엇인지 설명해 주세요
        
        레이아웃을 변경할 때 크기를 변경할 경우 리렌더링 측면에서 최적화된 방법은 무엇일까요?
        

🔥 **피드백(13~15)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 동기 비동기에 대한 자신의 생각과 실제 겪었던 문제를 어떻게 해결했는지 설명이 좋았습니다. ‘이걸 알고 사용하는구나’ 라는 느낌이 들었습니다. | 14.
    - 딜레이가 길게 걸리는 경우에 대한 꼬리 질문에 어떤 작업에서 어떤 알고리즘을 적용했을 때 시간이 오래걸려 비동기를 적용했다는 실제 사례에 대한 설명이 충분해서 좋았습니다.
    15. 
    - 순서에 따라, URL입력부터 화면그리기, JS 실행까지 설명이 좋았습니다. |
    | 개선사항 | 이건 사실 저희 모두에게 해당되는 사항이겠지만, 답변 내용 자체는 좋지만 너무 부가적인 설명이 들어가 있어서 조금 루즈해 질 수도 있겠다 라는 생각이 들었습니다. 조금 더 간략하고 핵심적인 부분만 간추려서 답변하면 더 좋을 것 같습니다. | 13. 
    - 호이스팅 설명에서 코드 예시는 빼도 좋을 것 같습니다.
    - var, let, const를 얘기한다면 let, const의 레퍼런스 에러까지 언급하면 좋을 것 같습니다.
    
    14.
    - 개인적으로 동기 비동기에서는 Promise와 async / await에 대한 내용이 따라나오는게 좋을 것 같습니다. |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 13번 문제
    전체적인 설명의 퀄리티가 좋았습니다.조금 더 압축하면 좋은 설명이 될 것 같습니다.
    14, 15
    필요한 설명들이 다 들어있었습니다. | 13. 14. 15.
    모든 질문에서 질문 내용에 대한 이해도를 잘 확인할 수 있었습니다.
    14.
    - UX부분에 대한 비동기 사용경험이 없다고 말씀해주시고, 이어지는 꼬리 질문에 실제 사용 경험을 잘 설명해주셔서 좋았습니다. |
    | 개선사항 | 14번 문제
    경험에 대한 꼬리질문에서 경험이 없다면 간단한 예시로 대처할수 있을지도..?
    - 주관적 의견 -
    
    답변 속도가 빨라졌구나 라고 항상 인지하시면 좋을듯합니다. | 13.
    - 내용은 충분히 좋았으나, 잘 요약한다면 더 좋은 답변이 될 것 같습니다.
    - 꼬리질문에서 잘 모르는 부분에 대한 미사여구를 짧게 줄인다면 좋을 것 같습니다.
    (개인적인 예시로 “제가 아는 한에서 말씀드리면 등…)
    14. 
    - 13번과 동일하게 답변 시작 전 미사여구를 줄이고 바로 본론으로 들어간다면 면접관을 집중시키는데 더 좋을 것 같습니다. |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 13번 문제
    호이스팅과 그 동작 원리에 대해서 스코프를 부가적으로 설명하여 명확하게 이해가 됐습니다.
    14, 15
    필요한 설명들이 다 들어있었습니다. | 중간에 말이 살짝 꼬이실 때, 차분하게 다시 설명드리겠습니다. 라고 말한 뒤 이어가는 부분이 아주 좋았습니다. 면접 분위기가 끊기지 않고 자연스럽게 이어질 수있었습니다. |
    | 개선사항 | 13번 문제
    스코프 등 부가적인 설명은 뒤쪽에 자연스럽게 덧붙이는 구조로 바꾸면 더 좋을 것 같습니다.
    14번 문제
    다양한 웹 API 등의 비동기 중 몇가지를 예로 들때는 전체적인 기술의 베이스를 알고있다는 전제가 필요할 것 같습니다.
    - 주관적 의견 - | 15번 질문에서 DNS 조회 → http 요청 등 필요한 부분 설명은 잘 해주셨지만, 그 이후 과정을 좀 더 설명해주셨으면 좋았을 것 같습니다. |
    
- 이지혜
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 전체적인 톤이 안정적이어서 좋았습니다.
    15. 꼬리질문을 너무 잘 답변해주셔서 좋았습니다. | 13. 호이스팅에 대해서 잘 설명해 주셨습니다. TDZ에 대해서도 잘 알고 계신것 같아 좋았습니다.
    
    14. 동기와 비동기가 무엇인지, 비동기 프로그래밍이 왜 필요한지에 대해서 잘 설명해 주셨습니다. |
    | 개선사항 | 13. 내용이 많이 간략화되어서 var, let const 정도만 간단하게 포함시켜서 방지법 등을 같이 설명하면 더 좋을 것 같습니다.
    14. 비동기 사용 예시나 비오기가 처리되는 과정을 조금 더 자세하게 답변할 수 있도록 대비하시면 좋을 것 같습니다. | 13. 호이스팅에 대해 설명해 주실 때, var, let, const 키워드에 대해 설명해 주신 다음 함수 호이스팅도 같이 설명해 주시면 더 좋은 답변이 될 것 같습니다.
    
    14. 비동기 관련해서 callback, promise, async/await 의 각각 장단점과 해당 개념들이 어떤 단점을 보완하고자 나온건지 숙지 하시면 아마 더 좋은 답변을 하실 수 있지 않을까 생각합니다. |

---

16. GET, POST 방식의 차이점에 대해서 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        첫번째는 요청에 데이터를 포함하는 방식입니다.
        GET 방식은 http 요청 패킷의 헤더에 포함된 URL 에 데이터를 넣을 수 있습니다.
        반면 POST 방식은 패킷의 바디 부분에 데이터를 저장해서 보냅니다.
        두번째는 데이터의 가시성입니다.
        get 방식은 데이터가 url 에서 모두 노출되기 때문에 개인정보를 포함해선 안됩니다. post 방식은 데이터가 바디에 들어가있어서 완벽한 보안은 아니지만 엑세스 로그 등의 작업에서 노출이 되지 않습니다.
        세번째는 데이터의 길이 제한입니다.
        get 방식은 데이터를 포함한 전체 URL 이 2048 글자 이내여야 하지만 post 방식은 데이터 길이에 제한이 없습니다.
        마지막으로 멱등성의 차이가 있습니다.
        get 요청은 보통 정보 조회에 사용해서 요청 횟수에 상관없이 응답이 동일하고, post 요청은 데이터 생성에 사용해서 여러번 요청했을 때, 변화가 존재합니다.
        (post 캐싱이 가능한가? https://stackoverflow.com/questions/626057/is-it-possible-to-cache-post-methods-in-http)
        
    - 오경민
        
        GET은 주로 서버에 데이터를 요청할 때 사용됩니다. 요청을 보낼 때 데이터를 body에 담지 않고, 쿼리스트링 형태로 보내기 때문에 url에 정보가 노출되어 보안에 취약합니다. 데이터 요청 길이에 제한이 있으며, 불필요한 요청을 줄이기 위해 요청이 캐싱될 수 있습니다.
        
        POST는 데이터를 생성하거나 업데이트하기 위해 사용합니다. body에 데이터를 담아 요청하고, 데이터 길이에 제한이없으며
        캐싱이 되지 않습니다.
        
    - 김섭찬
        
        (GET과 POST는 HTTP 프로토콜에서 데이터를 서버와 주고받기 위한 두 가지 주요 메서드)
        GET, POST는 데이터 전송방식과 사용 목적에 차이가 있습니다.
        
        GET은 URL의 쿼리 문자열을 통해 데이터를 전송합니다. 데이터가 URL에 노출되어 있어 보안성이 낮고 데이터 길이에 제한이 있습니다.
        데이터 조회, 검색에 사용되어 동일한 요청을 여러번 실행했을 때 동일한 결과를 가져옵니다.
        
        POST는 body에 데이터를 포함하여 전송합니다. 데이터가 body에 포함되어 데이터 길이에 제한이 없고, 비교적 안전하지만 암호화를 사용하지 않으면 쉽게 노출될 수 있습니다.
        데이터를 서버에 제출하거나, 서버 상태를 변경할 때 사용합니다. 그렇기 때문에 동일한 요청을 여러번 실행했을 때 같은 결과를 보장하지 않습니다.
        
        추가적으로 GET 요청은 캐시, 북마크가 가능하지만, POST 요청은 불가합니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        GET, POST의 캐시, 북마크 가능 여부에 대해서 설명해주세요
        
        GET 메서드는 URL 말고 Body에는 데이터를 담을 수 없나요?
        
        업데이트 메서드 중 put, patch 의 차이점을 아시나요
        
17. Server Side Rendering, Client Side Rendering, Static Site Generation 의 장단점을 설명해주실 수 있을까요?
    
    ✅ **답변**
    
    - 방혜찬
        
        csr 은 유저가 간단한 인덱스 HTML 파일을 받고 자바스크립트 번들 파일로 받아오는 방식입니다.
        처음부터 번들 파일을 한번에 로드하기 때문에, 이후 페이지 이동 등 후속 작업의 로드 시간이 줄어드는 장점이 있지만, 번들 파일의 용량이 그만큼 크기 때문에 유저가 상호작용이 가능하기 까지 로딩 시간이 길어지고 유저의 사용환경에 따라 렌더링의 최적화가 되지 않을 수 있다는 단점이 있습니다.
        ssr 은 유저가 사용할 템플릿과 데이터, 페이지 로직 등을 사용자 요청 시 서버에서 완성된 HTML 을 만들어서 전송해주는 방식입니다.
        브라우저에서 사용 가능한 페이지를 바로 로드하기 때문에 초기 페이지 로딩이 빠른 장점이 있고, 페이지가 다 만들어져 있기 때문에 SEO 에 친화적이라는 장점이 있습니다. 다만 자바스크립트 파일을 다운받고 페이지를 렌더링해야 하기 때문에 초기 로딩속도가 느리다는 단점이 있습니다.
        ssg 는 사용자가 웹페이지에 접속할 때가 아닌, 개발자가 코드를 빌드할 때 HTML을 미리 렌더링하는 방법입니다.
        그렇기 때문에 어떤 방법보다 유저 브라우저에서 빠르게 컨텐츠를 렌더링할 수 있습니다.
        단, 빌드 타임에 페이지를 생성하기 때문에 사용자에 맞게 정보를 담기가 어렵다는 단점이 있습니다.
        (seo? 웹 크롤러가 웹페이지를 색인에 추가하기 전 코드를 스캔할 때 유용한 코드로 보이기 위한 과정입니다.)
        
    - 오경민
        
        ssr은 서버에서 페이지를 미리 렌더링하고 클라이언트에게 보내주는 방식이기 때문에 초기 로딩속도가 빠르고, seo에 유리하다는 장점이 있지만, 페이지를 이동할 때마다 서버에서 렌더링을 하기 때문에 페이지간 이동시에는 조금 느리다는 단점이 있습니다.
        
        csr은 브라우저에서 페이지를 렌더링하는 방식입니다. 초기 로딩이 완료되면 페이지 전환시 전체적인 렌더링이 발생하지 않기 때문에 페이지 이동이 빠르지만, 자바스크립트 파일을 다운받고 페이지를 렌더링해야 하기 때문에 초기 로딩속도가 느리다는 단점이 있습니다.
        
        ssg는 빌드 시점에  페이지를 미리 렌더링하는 방식으로, 미리 만들어둔 페이지를 제공하기때문에 렌더링 속도가 훨씬 더 빠르고, 미리 만들어둔 페이지를 제공함으로써 seo에도 유리합니다. 하지만 데이터가 정적이기 떄문에, 동적 컨텐츠 대응이 어렵다는 단점이 있습니다.
        
    - 김섭찬
        1. 각각 설명한다면
        CSR은 클라이언트 측에서 모든 렌더링이 이루어져, 사용자는 빠르고 인터랙티브한 경험을 할 수 있습니다.
        또한 앱의 상태 관리 및 업데이트가 용이합니다.
        서버는 정적파일(HTML, JS, CSS)을 제공하기만 하면 되어 서버 부하가 적습니다.
        초기 로드 이후 필요한 데이터만 요청해, 네트워크 트래픽이 줄어듭니다.
        단점은 JS파일을 모두 다운로드하고 실행한 후 콘텐츠가 보여, 초기 로드 시간이 길어질 수 있습니다.
        검색 엔진 봇이 JS를 실행하지 못하는 경우, 콘텐츠를 인덱싱하지 못할 수 있습니다.
        
        서버사이드렌더링은 서버에서 미리 렌더링된 HTML을 제공해 빠른 화면 제공이 가능합니다. 크롤러가 완전한 HTML콘텐츠를 가져올 수 있고, 검색 엔진 봇이 콘텐츠를 쉽게 인덱싱할 수 있어 SEO 친화적입니다.
        단점은 모든 요청에 대해 서버가 HTML을 생성해야해 서버 부하가 증가할 수 있습니다.
        또한 페이지 이동시마다 서버에서 페이지를 생성하는데 시간이 걸려 첫번째 바이트 시간(TTFB)이 느립니다.
        (TTFB: 브라우저가 페이지를 요청한 후 서버로부터 정보의 첫 번째 바이트를 수신하는 시간)
        
        SSG은 모든 페이지가 미리 렌더링되어 정적 파일로 제공되므로, 로딩 속도가 매우 빠릅니다.
        서버 요청이 필요 없어 서버 부하가 적습니다.
        SSR과 같이 미리 생성된 HTML 파일이 제공되어, 검색 엔진이 쉽게 인덱싱 할 수 있습니다.
        동적 서버 코드가 없어, 서버 공격 면적이 줄어 보안성이 높아집니다.
        단점은 사이트의 모든 페이지를 미리 렌더링해, 빌드 시간이 길어질 수 있습니다. 그래서 콘텐츠가 자주 변경되는 사이트에는 적합하지 않을 수 있습니다. 동일한 이유로 유연성이 부족합니다.
        2. 통합 요약 버전
            
            서버사이드렌더링은 미리 렌더링된 HTML을 제공해 초기 화면 제공이 빠르고, SEO친화적인 장점이 있습니다.
            단점으로는 페이지 이동, 요청마다 페이지를 생성해야해 서버 부하가 증가할 수 있고, 정보의 첫 수신 시간이 길어질 수 있습니다.
            
            클라이언트사이드렌더링은 클라이언트 측에서 모든 렌더링이 이루어져 사용자는 빠르고 인터랙티브한 경험을 할 수 있습니다.
            또한 앱의 상태관리 및 업데이트가 용이합니다. 그로인해 서버 부하가 비교적 적고, 네트워크 트래픽을 줄일 수 있습니다.
            단점은 긴 초기 화면 로드 시간과 SEO 문제가 있습니다.
            
            서버사이드제네레이션은 모든 페이지가 미리 렌더링되어 정적 파일로 제공되므로, 초기 화면 로드 속도가 매우 빠릅니다.
            그래서 서버 부하가 적고, SEO 친화적입니다. 동적 서버 코드가 없어, 서버 공격 면적이 줄어들어 보안성도 높아집니다.
            단점은 사이트의 모든 페이지를 미리 렌더링해 빌드 시간이 깁니다. 콘텐츠가 자주 변경되거나, 실시간 업데이트가 필요한 경우 적합하지 않습니다.
            
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        SSR, CSR, SSG 의 장점에 맞는 사용예시 하나씩 설명해주실래요?
        
        React 혹은 Next.js를 Vercel로 배포하셨다면, 서버리스의 콜드부팅에 대한 고민을 해보신 경험이 있으신가요?
        
        SSR 에서 서버 부하를 줄이는 방법을 아시나요?
        
        왜 SSR이 SEO 에 더좋나요?
        
18. 쿠키, 세션, 웹스토리지의 차이에 대해 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        쿠키는 브라우저 저장소의 한 종류로 키-밸류 형태로 이름, 값, 만료시간 정보가 들어있습니다.
        만들어진 쿠키는 브라우저가 Request Header 에 자동으로 포함되어 서버에 전송한다.
        
        세션은 클라이언트에 저장하는 쿠키와 다르게 서버에서 관리합니다.
        서버에서 클라이언트에게 세션 id를 부여하고 관리합니다.
        
        웹 스토리지는 쿠키와 마찬가지로 브라우저 저장소입니다.
        마찬가지로 키-밸류 형태로 저장하며 쿠키보다 훨씬 큰 용량을 지원합니다.
        
        스토리지는 크게 로컬, 세션 스토리지로 나눌 수 있습니다.
        
        로컬 스토리지같은경우 도메인이나 포트, 프로토콜이 같다면 url 경로가 다르더라도 같은 값을 유지하고, 직접 값을 제거하는게 아니라면 데이터를 영구적으로 유지합니다.
        
        세션스토리지 같은 경우 일시적인 데이터를 저장할 수 있는 공간입니다. 이런 데이터는 사용자가 브라우저를 닫는 즉시 삭제되며, 로컬과 다르게 url 경로가 다르면 데이터가 공유되지 않습니다.
        
    - 오경민
        
        쿠키는 브라우저 저장소의 한 종류로 키-밸류 형태의 파일로  이름,값, 만료시간 정보가 들어있습니다.
        만들어진 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request 사이에 Request Header 를 넣어서 자동으로 서버에 전송한다.
        
        세션은 클라이언트에 저장하는 쿠키와 다르게 서버에서 관리합니다.
        클라이언트 구분을 위해 세션id를 부여하고 브라우저에 접속한 뒤 브라우저를 종료할 때까지 인증상태를 유지합니다.
        
        웹 스토리지는 쿠키와 마찬가지로 브라우저 저장소입니다.
        마찬가지로 키-밸류 형태로 저장하며 쿠키보다 훨씬 큰 용량을 지원합니다.
        
        스토리지는 크게 로컬, 세션 스토리지로 나눌 수 있습니다.
        
        로컬 스토리지같은경우 도메인이나 포트, 프로토콜이 같다면 url 경로가 다르더라도 같은 값을 유지하고, 직접 값을 제거하는게 아니라면 데이터를 영구적으로 유지합니다.
        
        세션스토리지 같은 경우 일시적인 데이터를 저장할 수 있는 공간입니다. 이런 데이터는 사용자가 브라우저를 닫는 즉시 삭제되며, 로컬과 다르게 url 경로가 다르면 데이터가 공유되지 않습니다.
        
    - 김섭찬
        
        
    - 이지혜
        1. 쿠키는 클라이언트의 브라우저에 데이터를 저장하며, 보안강도가 상대적으로 낮기 때문에 민감한 데이터를 저장하기에는 적합하지 않습니다. 만료일을 설정할 수 있으며 만료일까지 데이터가 유지됩니다. 
        주로 사용자의 로그인 상태를 유지하거나 설정을 저장할때 사용할 수 있습니다.
        **서버와 클라이언트 간 상대를 유지하기 위해 사용됩니다. 서버에 전송되는 모든 HTTP 요청과 함께 전송됩니다**
        2. 세선은 서버에 데이터를 저장하고, 데이터를 서버에서 관리하기 때문에 클라이언트에서 조작이 불가능하여 비교적 보안 강도가 높습니다. 서버 측에서 설정한 시간 동안 유효하며, 주로 일정 시간동안 활동이 없으면 만료되는 방식으로 사용합니다. 민감한 사용자 데이터나 로그인 정보를 관리할 때에 사용할 수 있습니다. 
        3. 웹 스토리지는 클라이언트의 브라우저에 저장되나, 쿠키와는 HTTP 요청과 함께 자동으로 전송되지 않는 다는 차이점이 있습니다. 쿠키보다 저장할 수 있는 데이터 규모가 크기 때문에 클라이언트에 대규모 데이터를 저장하고 싶을 때 사용할 수 있습니다. 
    - **❓ 꼬리질문**
        
        쿠키, 세션, 웹 스토리지의 사용 용도에 대해서 설명해주세요
        쿠키의 용량을 아시나요?
        
        쿠키의 보안 속성 한 두가지만 말해주세요.
        
        로컬 스토리지, 세션 스토리지의 차이점?
        
        쿠키와 웹 스토리지 용량에 차이가 있는 이유를 아시나요?
        
        토큰 인증에 대해서 아시나요?
        

🔥 **피드백(16~18)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 16. GET, POST 에 대한 질문은 각각을 비교설명 해주시면서 차이점에 대해 잘 말씀해 주셔서 좋았습니다.
    
    17. 각각의 렌더링 방식에 대해서도 잘 말씀해 주셨습니다. 사실 루즈해질 수 있는 질문이였는데 중요한 부분을 잘 간추려서 말씀해주셨습니다. | 16.
    - 차이점을 첫 번째, 두 번째, 나누어 하나씩 비교했던 부분이 듣기에 좋았습니다.
    - 캐시 가능 여부에 대한 꼬리질문에서는 오히려 제가 몰랐던 부분에 대해 알 수 있었습니다. |
    | 개선사항 | 17번 질문 : 꼬리질문에서 CSR,SSR,SSG 각각의 렌더링 방식이 어떤 서비스에 사용되면 좋을지에 대한 질문은 조금 더 알아보시면 더 좋을 것 같습니다.
    페이지 렌더링 방식이 프론트에서 빠질 수 없는 내용이다 보니 이 부분은 짚고 넘어시면 좋을 것 같습니다. |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 전체적으로 설명이 간략하고 좋았습니다. |  |
    | 개선사항 | 16. 비교를 할 때 차이점 별로 두가지의 차이점 비교하는 것은 어떨까요
    - 주관적 -
    17. 꼬리 질문에 이미 앞에서 설명한 내용은 과감히 생략하고 추가적인 내용만 설명하면 좋을 것 같습니다.
    18. 웹 스토리지쪽 설명은 조금 더 줄일 수 있지 않을까 생각합니다.
    꼬리질문을 받을 때 추임새에 조심하고, 모르는 질문에 대한 답변을 미리 준비하면 좋겠습니다. | 17. 
    - React를 Vercel(서버리스) 환경에서 배포하셨다면 콜드부팅에 대해 알고계시면 좋을 것 같습니다.
    18.
    쿠키, 세션, 웹 스토리지에 대해서 잘 설명해주셨으나, 간단한 사용 용도까지 1,2개 얘기하실 수 있다면 내용을 알고있다는 것에 더 뒷받침이 될 것 같습니다. |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 질문 답변과 꼬리 질문에 대한 답변이 깔끔하고 편안하게 들을 수 있는 톤과 속도여서 잘 들었습니다. | 질문에 대한 답변, 그리고 꼬리질문에 대한 답변 중 실제 경험을 토대로 잘 풀어서 말씀해 주셔서 훨씬 더 신뢰성있는 답변이 되었습니다. 이 부분이 아주 좋았습니다. |
    | 개선사항 | 17. 장단점을 설명할 때, 간단하게 하나씩만 왜 그런지 기술적인 원인을 덧붙이면 좋지 않을까요?
    - 주관적 - | 딱히 개선사항은 없는 것 같습니다. 오늘만큼은 너무 잘하셨습니다. |
    
- 이지혜
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 18. 간단한 개념과 사용 예시를 같이 설명해주셔서 좋았습니다. | 내용 설명은 잘 알고 대답해 주셔서 좋았습니다. 꼬리질문에도 잘 대답해 주셔서 좋았습니다. ( 핵심만 간추리시면 더 좋을 듯!) |
    | 개선사항 | 17. 내용의 전반적인 설명이 너무 길어진 감이 있어서 핵심 키워드만 언급하고 자잘한 설명은 꼬리질문을 유도하는 방향으로 수정하시면 좋을 것 같습니다. | 전체적인 답변내용은 좋았으나, 조금 더 핵심적인 부분만 간추려서 설명해 주시면 더 좋을 것 같습니다.
    
    ”SSR은 ~~약자입니다” 이런 부분은 과감하게 생략하셔도 좋을듯 합니다 ! |

---

19. SEO란 무엇이고 SEO를 진행하는 방법에 대해 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        seo 는 웹사이트가 검색 엔진의 검색 결과에서 더 높은 순위를 얻을 수 있도록 최적화하여 사용자들의 방문율을 높일 수 있는 작업입니다.
        먼저 seo 를 위해서는 먼저 웹 페이지의 타겟이 되는 키워드를 설정한 후 메타 태그의 타이틀, 디스크립션, 키워드 태그 등을 작성합니다.
        사이트맵을 제작해서 검색엔진이 웹페이지들을 빠짐없이 검색할 수 있게 합니다.
        또한 사이트의 로딩 속도를 높이거나 https 프로토콜을 적용하여 보안성을 높이면 더 점수를 받을 수 있습니다.
        마지막으로 웹사이트 외부적으로는 타 웹사이트에서 백링크를 받음으로서 점수를 받을 수 있습니다.
        
        메타태그에 작성된 내용을 통해 검색엔진이 웹 페이지의 카테고리를 분류하고, 검색 결과에 노출될 내용을 작성하게 됩니다.
        seo 가이드:https://seo.tbwakorea.com/blog/seo-guide-2022/#part5
        구글 사이트맵 가이드:https://developers.google.com/search/docs/crawling-indexing/sitemaps/build-sitemap?hl=ko
        ttv vs tti:https://velog.io/@yjinhann/TTV-TTI
        
    - 오경민
        
        SEO는 웹 사이트를 검색 엔진 결과화면에서 더 높은 순위에 노출시키기 위해 수행되는 방법입니다.
        SEO를 진행하는 방법으로는 메타 태그를 활용해 각 페이지의 키워드를 포함시키는 방법이 있습니다. 또한 시맨틱 태그를 활용해 검색엔진이 브라우저 구조를 더 쉽게 파악할 수 있도록 하는 방법도 있습니다.
        
    - 김섭찬
        
        인터넷에서 데이터를 전송하기 위해 사용되는 전송 계층 프로토콜입니다. 이 두 프로토콜은 데이터 전송 방식과 신뢰성 측면에서 차이가 있습니다.
        
        TCP는 연결지향적 프로토콜로 데이터 전송 전 송신자와 수신자의 연결을 설정합니다. 이 연결은 ‘3-way handshake’ 과정을 통해 이루어집니다.
        데이터 전송 시 신뢰성과 데이터 순서를 보장하며, 패킷이 손실, 손상되었을 때 재전송을 요청합니다.
        또한 흐름제어와 혼잡제어를 지원합니다.
        단점은 신뢰성 보장을 위해 헤더와 제어 메시지가 필요해 오버헤드가 상대적으로 큽니다.
        
        데이터의 신뢰성이 중요한
        HTTP, 이메일, 파일전송 프로토콜이 TCP를 사용합니다.
        
        UDP는 비연결지향적 프로토콜로 송신자와 수신자의 연결 없이 데이터를 전송합니다. 이때 ‘best-effort’ 방식을 사용해 전송합니다.
        데이터 전송 시 순서 보장, 재전송 요청 등의 기능이 없어
        데이터가 손실되거나 순서가 뒤바뀔 수 있습니다.
        장점은 헤더나 제어 메시지가 거의 없어, 오버헤드가 작고 전송 속도가 빠릅니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        웹 사이트 외부적으로 SEO 관련된 내용이 있을까요?
        
        React말고 Next를 적용해야하는 이유를 SEO 관점에서 설명해주세요
        
        SEO, 페이지 성능 점수는 어디서 확인하셨나요? → Page Speed Insight, LightHouse
        
        SEO 최적화 중 내부 링크에 대해서 알고있나요?
        
20. TCP/UDP에 대해서 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        TCP 와 UDP 는 데이터 통신을 위한 프로토콜입니다.
        먼저 TCP 는 데이터 전송 시 신뢰성이 보장된다는 장점을 가진 프로토콜입니다.
        송신자와 수신자간 연결을 설정한 후에 송신자 측에서는 데이터 전송 시 흐름 제어와 혼잡 제어를 통해 네트워크상에 병목현상을 방지합니다.
        수신자 측에서는 도착한 데이터를 순서에 맞게 재조립하고, 데이터가 중간에 손실된 경우에도 재전송을 요청하여 다시 받아올 수 있습니다.
        다음으로 UDP 는 신뢰성보다 빠른 속도를 장점으로 가진 프로토콜입니다.
        송신자는 수신자와 연결을 따로 설정하지 않고 ip와 port를 기반으로 데이터를 바로 전송하며, 수신 여부도 확인하지 않습니다.
        수신자는 받은 데이터의 최소한의 오류만 검출하고 순서도 확인하지 않습니다.
        때문에 TCP 에 비해  신뢰성이 낮고 전송 속도가 빠릅니다.
        
        프로토콜은 컴퓨터 사이의 통신을 위해서 정한 규약으로, 메시지를 주고 받는 양식과 규칙을 말합니다.
        흐름제어는 데이터 송신자가 수신자의 데이터 처리속도를 보고 버퍼 오버플로우를 방지하기 위해 송신 속도를 조절하는 것입니다.
        혼잡제어는 네트워크 내의 데이터 전송량이 과하다면 넘치지 않도록 조절하는 것입니다.
        정보의 소통량이 과하다면 패킷을 조금만 전송하여 혼잡 붕괴현상이 일어나는것을 막는다.
        TCP - 파일 전송, UDP - 실시간 스트리밍
        
        **추가 질문 1**: TCP의 3-way handshake 과정은 무엇인가요?
        
        **답변**: 3-way handshake는 TCP 연결 설정 과정으로, 클라이언트가 서버에 SYN 패킷을 보내고, 서버가 SYN-ACK 패킷으로 응답하며, 클라이언트가 다시 ACK 패킷을 보내 연결을 확립합니다.
        
        **요약**: "TCP 연결 설정은 클라이언트와 서버 간에 SYN, SYN-ACK, ACK 패킷을 교환하여 이루어집니다."
        
        **추가 질문 2**: UDP에서 패킷 손실이 발생하면 어떻게 되나요?
        
        **답변**: UDP는 패킷 손실 시 재전송을 하지 않습니다. 애플리케이션 레벨에서 패킷 손실을 처리해야 합니다.
        
        **요약**: "UDP는 패킷 손실 시 재전송하지 않으며, 애플리케이션에서 이를 처리해야 합니다."
        
        **추가 질문 3**: TCP와 UDP의 포트 번호는 어떻게 사용되나요?
        
        **답변**: TCP와 UDP 모두 포트 번호를 사용하여 특정 애플리케이션 프로세스를 식별합니다. 예를 들어, HTTP는 TCP 80번 포트를 사용하고, DNS는 UDP 53번 포트를 사용합니다.
        
        **요약**: "TCP와 UDP는 포트 번호를 사용하여 애플리케이션 프로세스를 식별합니다."
        
    - 오경민
        
        TCP와 UDP는 데이터 전송을 위해 사용하는 프로토콜이다.
        TCP는 연결 지향형이며, 신뢰성과 데이터 순서를 보장하며 흐름과 혼잡제어를 통해 데이터와 전송 속도를 조절합니다. 또한 신뢰성 보장을 위해 추가적인 정보를 포함하고 핸드셰이크 매커니즘으로 인해 더 많은 오버헤드가 발생합니다.
        
        UPD는 비연결형입니다. 신뢰성과 데이터 순서가 보장되지 않고, 흐름 및 혼잡제어가 없으며 연결 설정 과정이 없기 때문에 오버헤드가 낮게 발생합니다.
        
    - 김섭찬
        
        인터넷에서 데이터를 전송하기 위해 사용되는 전송 계층 프로토콜입니다. 이 두 프로토콜은 데이터 전송 방식과 신뢰성 측면에서 차이가 있습니다.
        
        TCP는 연결지향적 프로토콜로 데이터 전송 전 송신자와 수신자의 연결을 설정합니다. 이 연결은 ‘3-way handshake’ 과정을 통해 이루어집니다.
        데이터 전송 시 신뢰성과 데이터 순서를 보장하며, 패킷이 손실, 손상되었을 때 재전송을 요청합니다.
        또한 흐름제어와 혼잡제어를 지원합니다.
        단점은 신뢰성 보장을 위해 헤더와 제어 메시지가 필요해 오버헤드가 상대적으로 큽니다.
        
        데이터의 신뢰성이 중요한
        HTTP, 이메일, 파일전송 프로토콜이 TCP를 사용합니다.
        
        UDP는 비연결지향적 프로토콜로 송신자와 수신자의 연결 없이 데이터를 전송합니다. 이때 ‘best-effort’ 방식을 사용해 전송합니다.
        데이터 전송 시 순서 보장, 재전송 요청 등의 기능이 없어
        데이터가 손실되거나 순서가 뒤바뀔 수 있습니다.
        장점은 헤더나 제어 메시지가 거의 없어, 오버헤드가 작고 전송 속도가 빠릅니다.
        
        실시간 전송이 중요하고, 약간의 데이터 손실이 허용되는
        스트리밍, 온라인 게임, DNS 조회 등에 UDP가 사용됩니다.
        
    - 이지혜
        
        TCP와 UDP는 인터넷에서 데이터를 저송하는 두가지 주요 프로토콜 입니다.
        
        **TCP(Transmission Control Protocol)**는 신뢰성 있는 데이터 전송을 보장하는 프로토콜입니다. 
        3-way handshake를 통해 두 시스템을 연결하고, 데이터 전송이 끝나면 4-way handshake를 통해 연결을 종료합니다. 데이터의 전송을 확인할 수 있고, 데이터의 순서를 보장한다는 특징이 있습니다.
        
        **UDP(User Datagram Protocol)**는 빠른 데이터 전송을 중요시하는 프로토콜입니다.
        
        별도의 연결 설정이 없으며 데이터 전송 여부를 확인할 수 없고 순서가 변경될 수 있지만 전송 속도가 빠릅니다.
        
        이러한 특징들 때문에 TCP는 주로 웹페이지 로딩, 이메일 송수신, 파일 전송등 신뢰성이 중요한 상황에서 사용되고, UDP는 온라인 게임, 실시간 스트리밍등 속도가 중요한 경우에 사용됩니다.
        
    - **❓ 꼬리질문**
        
        TCP/UDP와 websocket은 어떤 차이가 있나요?
        
        송신자, 수신자 연결은 어떻게 이루어지나요? → 3way로 연결, 4way로 해제
        
        신뢰성 보장을 위해서 어떤 것들이 필요한가요? → 헤더, 제어 메시지
        
        UDP or TCP는 주로 어떤 데이터 전송에 사용되나요?
        
        흐름제어, 혼잡제어에 대해서 간단하게만 설명해주세요.
        
21. http와 https의 차이점에 대해 설명해주세요
    
    ✅ **답변**
    
    - 방혜찬
        
        두가지 모두 통신 프로토콜이지만 가장 큰 차이점은 바로 보안성입니다.
        기존의 http 는 암호화를 지원하지 않기 때문에 패킷 스니핑을 통해서 요청과 응답 패킷 안의 내용을 그대로 확인할 수 있고  보안성이 매우 취약합니다.
        https 는 http 프로토콜에 TLS 암호화를 적용한 것입니다.
        TLS 암호화는 대표적으로 공개 키 암호화 방식을 사용하는데, 서버와 유저가 미리 암호화에 사용할 키 쌍을 미리 교환하기 때문에 해커가 중간에 패킷 스니핑을 해도 복호화를 할 수 없어 데이터가 유출되지 않습니다.
        
        스니핑이란 네트워크 상에서 자신이 아닌 다른 유저간의 통신상 패킷을 훔쳐보는 것을 의미합니다.
        
        **추가 질문 1**: HTTPS가 데이터를 암호화하는 과정은 어떻게 이루어지나요?
        
        **답변**: HTTPS는 SSL/TLS 프로토콜을 사용하여 데이터를 암호화합니다. 클라이언트와 서버가 SSL/TLS 핸드셰이크 과정을 통해 대칭키를 생성하고, 이 대칭키를 사용하여 데이터를 암호화하여 전송합니다.
        
        **요약**: "HTTPS는 SSL/TLS 핸드셰이크를 통해 대칭키를 생성하고 데이터를 암호화하여 전송합니다."
        
        **추가 질문 2**: SSL과 TLS의 차이점은 무엇인가요?
        
        **답변**: SSL (Secure Sockets Layer)은 초기 버전의 보안 프로토콜이고, TLS (Transport Layer Security)는 SSL의 개선된 버전입니다. TLS는 더 강력한 암호화 알고리즘과 보안 기능을 제공합니다.
        
        **요약**: "TLS는 SSL의 개선된 버전으로, 더 강력한 암호화와 보안 기능을 제공합니다."
        
        **추가 질문 3**: HTTP에서 HTTPS로 마이그레이션할 때 고려해야 할 사항은 무엇인가요?
        
        **답변**: HTTPS로 마이그레이션할 때는 SSL/TLS 인증서 발급, 서버 설정 변경, 모든 리소스의 HTTPS 사용, 기존 HTTP URL의 리다이렉션 설정 등을 고려해야 합니다.
        
        **요약**: "HTTPS로 마이그레이션 시 인증서 발급, 서버 설정 변경, 리소스와 URL의 HTTPS 사용 등을 고려해야 합니다."
        
    - 오경민
        
        HTTP 와 HTTPS는 웹에서 데이터를 전송하는 프로토콜입니다. 이 둘의 주요 차이점은 보안에 관한 것입니다.
        HTTP는 데이터를 평문 형태로 전송하기 때문에 중간에서 데이터를 가로챌 수 있고, 보안 수준이 낮아서 설정이 간단하다는 특징이 있습니다.
        HTTPS는 SSL/TLS 프로토콜을 사용해 데이터를 암호화하여 전송합니다. 이로 인해 중간 공격자가 데이터를 읽거나 수정하는 것을 방지합니다.
        
    - 김섭찬
        
        http와 https 모두 인터넷에서 데이터를 주고받기 위한 프로토콜이지만, 보안 측면에 차이점이 있습니다.
        
        HTTP는 데이터를 암호화하지 않고 평문으로 전송해 보안성이 없습니다. 공공 웹사이트, 블로그 등 민감하지 않은 데이터 전송에 사용됩니다.
        
        암호화 작업이 없어 HTTPS에 비해 속도가 약간 빠를 수 있으나 현대적인 하드웨어, 네트워크 환경에서는 거의 무시할 수 있을 정로로 작습니다.
        
        HTTPS는 HTTP에 SSL/TLS 인증서를 사용하여 데이터를 암호화하고, 인증서를 통해 서버의 신원을 검증합니다. 보안성이 높아, 온라인 쇼핑, 인터넷 뱅킹, 로그인 페이지 등 보안이 중요한 데이터 전송에 사용됩니다. 
        검색엔진이 HTTPS웹을 선호해 SEO에 유리하고, 현재 대부분의 브라우저는 HTTPS를 사용하지 않는 웹사이트에 대해 경고 메시지를 표시합니다.
        
    - 이지혜
        
        HTTP와 HTTPS는 웹에서 데이터를 주고받는 프로토콜이며, 보안 측면에서 큰 차이가 있습니다.
        
        HTTP는 데이터를 암호화하지 않고 전송합니다. 사용자가 웹사이트에 입력한 정보 (이름, 비밀번호 등)가 평문으로 전송되는데 이로 인해 중간에 보안에 취약하다는 문제가 있습니다.
        
        HTTPS는 이를 보완하기 위해 나온 보안 프로토콜로 데이터를 암호화하여 전송합니다. 이를 위해 SSL 또는 TLS 프로토콜을 사용하며, 보안 인증서를 사용하여 웹사이트의 신원을 확인하고, 통신의 기밀성과 무결성을 유지합니다.
        
    - **❓ 꼬리질문**
        
        SSL/TLS 인증서를 발급받아 보셨나요?
        받아보셨다면 어떤 기관에서 발급받으셨나요?
        → Amazon Trust Services 등
        
        암호화에는 어떤 방식을 사용할까요?
        
        *TLS 이 SSL 을 대체하고 있는데, TLS 와 SSL 의 차이점이 무엇일까요?ㄹㅇ 안중요할듯;
        → (SSL의 명시적 연결과 TLS의 암시적 연결의 차이)*
        

🔥 **피드백(19~21)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 각 질문에 대한 설명은 너무 잘 해주셨고, 차이점을 묻는 질문에서도 잘 설명해 주셨습니다. 답변 내용 자체는 문제없이 잘 해주셨습니다. 실제 경험에 빗대어 설명 해주신 부분이 좋았습니다. | 전반적으로 모든 질문에 부족한 내용 없이 잘 답변해주셨습니다.
    꼬리 질문에 대한 답변도 실제 사용 경험 등을 말씀해주셔서 말씀하신 내용에 충분한 근거가 되었습니다. |
    | 개선사항 | SEO 점수 관련에 대해선 약간 말의 앞뒤가 안맞는다는 생각이 들었습니다.
    면접관 입장에서는 약간 이상하게 생각할 수도 있을 것 같습니다. 실제 이런 질문을 받는다면 어떻게 답을 하실지 한번 더 고민해 보시면 좋을 것 같습니다. | 19.
    SEO 설명 중 점수에 관한 설명을 해주셨고,
    이어지는 꼬리 질문에 Next.js에서 SEO를 적용했다고 말씀해주셨습니다.
    이후 이어진 ‘어디서 점수를 확인했는지’에 대한 질문에 점수를 확인해본 적 없다는 답변은 모순적으로 들릴 수 있을 것 같습니다. |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 이전보다 확실히 전체적으로 톤이 안정되신것같습니다. 당황할 수 있는 꼬리 질문 등에서도 좋은 톤으로 답변해주셨습니다. | 전반적인 내용과 설명해주시는 속도가 좋았습니다. |
    | 개선사항 | 19. 꼬리 질문에 답변하실 때 이미 설명한 내용을 과감히 생략해도 좋지 않을까 싶습니다.
    내용이 방대하지만 사실 카테고리들이 있기 때문에, 카테고리 별로 압축해서 설명해주시면 더 좋은 설명이 될 것 같습니다.(저도 못했기 때문에 같이 개선해보시죠..) | 19.
    - SEO가 워낙 방대한 내용이지만, 핵심적으로 적용해야할 키워드를 좀 더 설명해주신다면 좋을 것 같습니다.
    - React와 Next를 모두 사용해보셨을 때 SEO 관련한 장단점에 대해 충분한 설명이 필요할 것 같습니다.
    20.
    - 꼬리 질문에 대한 답변은 앞서 설명했던 내용은 제외하고 말씀해주신다면 좋을 것 같습니다.
    - 질문이 핵심 내용만 물어본다면 핵심만 말씀해주시면 좋을 것 같습니다. |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 19. SEO라는 방대한 내용을 카테고리별로 최대한 압축해서 핵심 키워드만 얘기하시는 방식이 정말 좋았습니다. | SEO질문 답변과 성과측정 경험사례까지 좋았습니다. 나머지 비교 설명하는 질문에서는 각각 차이점에 대해 잘 설명해 주셔서 좋았습니다. |
    | 개선사항 | 20.
    설명 내용의 압축이 필요할 것 같습니다. 자세한 설명보다는 19번처럼 짧은 키워드 중심으로 설명해주시고, 예시는 꼬리 질문에서 답변하도록 유도하는 방식도 괜찮지 않을까요?
    -주관적- | 20번 질문 같은 경우, 짧게 다루기가 힘든 내용이다 보니 어느정도 이해는 되지만 조금 더 핵심적인 내용만 간추려서 설명해 주셨다면 더 좋지 않았을까 하는 아쉬움이 있습니다. |
    
- 이지혜
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 오늘은 질문에 대해서 전체적으로 간략하고 핵심적인 내용만 얘기해주셔서 좋았습니다.
    20. 개념 설명 이후 예시 설명까지 좋았습니다.
    21. http 설명 이후 https 는 차이점 위주로 설명해주셔서 좋았습니다. | 20번 질문) TCP/UDP 차이점에 대해 간략하게 잘 설명해 주셨고, 3-way handshake 의 각 과정에 대해서도 잘 설명해 주셔서 확실히 TCP에 대해서 잘 알고계신다는 느낌을 받아서 좋았습니다.
    
    21번 질문) http vs https 질문도 내용이 길어질 수 있는 질문인데, 간략하게 핵심적인 부분만 간추려 잘 설명해 주셨습니다. |
    | 개선사항 | 20. 3way handshake 부분 설명할 때, syn syn-ack ack 같은 용어를 숙지하지 않으면 면접관이 잘 모른다라고 생각할 수도 있을 것 같습니다.
    21. 개선사항이라기 보다는 암호화 과정에 대해 조금 더 자세히 알아두면 어필이 될 것 같습니다. | UDP를 사용하여 신뢰성을 높이기 위한 프로토콜이나 방법은 무엇이 있는지에 대한 질문에서 1가지 정도만 가볍게 알고계서도 좋을듯 합니다. |

---

---

22. VanillaJS와 비교하여 리액트를 사용하는 이유에 대해 설명해주실 수 있을까요?
    
    ✅ **답변**
    
    - 방혜찬
        
        첫번째는 Virtual DOM 기능입니다.
        SPA 같이 변화가 많은 환경의 경우, 모든 변화를 메모리상에서 빠르게 연산하고 하나로 묶어서 한번의 업데이트를 실행시켜서 효율적입니다.
        두번째는 컴포넌트 구조와 재사용성입니다.
        화면의 구성요소들을 컴포넌트로 분리하고 개발하여 복잡한 화면 구성도 보기 쉬워지고, 같은 용도의 컴포넌트를 다른 프로젝트에서도 재사용할 수 있어 생산성이 향상됩니다.
        마지막은 JSX 문법입니다.
        리액트는 대부분 JS 의 확장 문법인 JSX 를 함께 사용하는데, 컴포넌트의 뷰를 HTML 처럼 작성할 수 있어서 컴포넌트 단위의 로직과 뷰를 한번에 볼 수 있어 개발과 유지보수가 쉬워집니다.
        
        **SPA** 란 처음 받아온 한 페이지 내에서 여러 페이지를 동적으로 재작성하여 서버와의 통신을 줄인 애플리케이션입니다.
        **컴포넌트**란 페이지에 렌더링되는 각각의 구성요소들로, 보통 SPA 프레임워크들에서 컴포넌트 단위로 로직과 뷰를 하나의 파일에 작성하여 개발하기 때문에 재사용성과 유지보수에 좋은 구조입니다.
        
    - 오경민
        
        바닐라 자바스크립트는 DOM 요소의 생성, 추가, 삭제등의 조작과 상태 변화등을 개발자가 명령형으로 제어하는 반면, 리액트는 React에게 UI를 어떻게 표현해야 할 지 알려주는 선언적 API를 제공해 UI 작성의 편리함을 제공합니다.
        
        DOM의 잦은 변경은 브라우저가 많은 연산을 수행하게 되어 웹 성능 저하의 원인이 됩니다.
        React는 메모리에 저장되는 실제 돔을 추상화한 가상 돔을 통해 변경이 발생한 부분만 반영하기 때문에  불필요한 리렌더링을 최소화하고 성능 최적화가 가능합니다.
        
    - 김섭찬
        
        React를 사용하는 이유는 여러 가지가 있습니다. 먼저, 컴포넌트 기반 아키텍처로 인해 재사용성과 유지보수성이 높아집니다. React의 Virtual DOM을 통해 실제 DOM 조작을 최소화하고, 효율적으로 업데이트할 수 있어 성능이 향상됩니다. 단방향 데이터 바인딩을 통해 데이터 흐름이 예측 가능하고, 디버깅이 용이해집니다. JSX를 사용하면 UI 코드를 더 직관적으로 작성할 수 있으며, 풍부한 라이브러리와 강력한 커뮤니티 지원을 받습니다. 또한, 서버 사이드 렌더링을 통해 초기 로딩 속도를 개선하고 SEO를 지원할 수 있으며, Hook과 다양한 상태 관리 라이브러리를 통해 상태 관리를 쉽게 할 수 있습니다. 이러한 이유들로 인해 React는 VanillaJS보다 복잡한 사용자 인터페이스를 구축하는 데 더 유리하고 효율적입니다.
        
    - 이지혜
        - 리액트는 자바스크립트 라이브러리로 UI를 구성하는 컴포넌트를 효율적으로 관리하고 렌더링하는데에 용이합니다. 리액트를 사용하는 몇가지 이유가 있는데요
            
            첫번째로, 리액트는 컴포넌트 기반 아키텍쳐이므로 UI를 독립적인 컴포넌트로 나누어 관리할 수 있게 해주기 때문에 코드의 재활용성이 높아지고 유지보수가 용이해집니다.
            
            두번째로, 가상DOM을 사용하여 변경된 부분만 효율적으로 업데이트하는 방식으로 성능을 최적화 할 수 있습니다. 
            
            세번째로, 리액트는 컴포넌트의 상태를 관리하는 기능을 내장하고 있어 UI 상태와 로직을 간단하게 관리할 수 있습니다. 
            
            이 밖에도 큰 커뮤니티와 생태계를 가지고 있다는 이점도 있습니다. 
            
            세번째로, 리액트는 컴포넌트의 상태를 관리하는 기능을 내장하고 있어 UI 상태와 로직을 간단하게 관리할 수 있습니다. 
            
            이 밖에도 큰 커뮤니티와 생태계를 가지고 있다는 이점도 있습니다. 
            
    - **❓ 꼬리질문**
        
        상태관리가 바닐라JS에서는 불가능한가요?
        
23. 상태의 불변성이 중요한 이유가 무엇인가요?
    
    ✅ **답변**
    
    - 방혜찬
        
        상태의 불변성을 활용하면 복잡한 구조를 가진 상태의 변화를 효율적으로 찾아낼 수 있습니다.
        큰 중첩을 가진 객체 데이터의 변화된 값을 찾아내는 중 깊은 비교는 매번 비교때마다 재귀적으로 여러번 비교를 하기 때문에 그만큼 UI 의 업데이트에 긴 비교시간이 필요합니다.
        상태의 불변성을 활용하면, 상태 변수의 참조값만 비교하여 변화를 판단하기 때문에, 깊은 비교보다 훨씬 간단하게 복잡한 상태 데이터를 비교할 수 있습니다.
        또한, 불변성을 유지하면 데이터의 변경이 명시적으로 이루어지기 때문에 코드의 유지보수가 더 쉬워집니다.
        
        얕은 비교는 첫번째 레벨의 값의 변경만 체크하고 깊은 비교는 객체를 재귀적으로 파고들어가 깊이에 따른 값의 변화가 있는지 모두 체크해야 합니다.
        상태를 업데이트하려면 새로 생성한 복제본을 수정한 후 업데이트에 사용합니다.
        
    - 오경민
        
        상태의 불변성은 리액트에서 성능 최적화와 예측 가능한 코드 유지에 중요합니다. 리액트에서는 얕은 비교를 통해 객체의 참조 주소값만을 비교함으로써 계산 리소스를 줄이고, 효율적으로 상태를 업데이트할 수 있게 해줍니다. 불변성을 유지하면 원본 데이터가 변경되지 않아 사이드 이펙트를 방지하고, 예측 가능성과 코드의 가독성을 높여주기 때문에 불변성이 중요하다고 할 수 있습니다.
        
        얕은 복사는 주소값을 복사하여 같은 메모리를 가리키기 때문에
        값이 변하면 가리키는 주소값이 같기 떄문에 원본 값도 변경됩니다.
        깊은복사는 객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식이기 때문에 값이 변해도 원본은 변하지 않습니다.
        
    - 김섭찬
        
        상태의 불변성은 예측 가능성과 디버깅 용이성을 높이며, 성능 최적화, 상태 관리의 단순화, 시간 여행 디버깅, 멀티스레딩 환경에서의 안정성, 함수형 프로그래밍과의 통합 등 다양한 이유로 중요합니다. 이러한 이유들로 인해, 특히 React와 같은 프레임워크에서는 상태의 불변성을 유지하는 것이 좋은 코딩 패턴으로 간주됩니다.
        
    - 이지혜
        
        상태의 불변성은 상태가 변경되지 않는다는 원칙을 의미하는데요, 
        
        리액트에서 상태의 불변성이 중요한 이유는 
        React는 상태나 props가 변경될 때 컴포넌트를 다시 렌더링합니다. 불변성을 유지하면 이전 객체와 현재 객체를 얕은 비교로 판단하기 때문에 더 효율적으로 비교할 수 있습니다. 이는 React가 변경된 부분만을 리렌더링할 수 있게 도와주어, 성능을 최적화하는 데 중요한 역할을 합니다.
        
    - **❓ 꼬리질문**
        
        말씀하신 불변성의 장점 중 멀티 쓰레드에 안전하다는 장점은 프론트엔드에서 어떤 예시가 있나요?
        
        성능 최적화라는 관점에 대해서 자세하게 설명해주세요
        
        얕은복사와 깊은복사의 차이에 대해 설명해 주세요
        
        성능 최적화에 있어 얕은 비교, 깊은 비교가 어떻게 다른가요?
        
24. 라이프사이클이 의미하는 바에 대해서 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        브라우저에서 화면을 구성하는 컴포넌트들의 생명 주기를 뜻합니다.
        라이프 사이클에는 대표적인 3가지 시점이 있습니다.
        첫번째는 컴포넌트가 DOM 이 생성되고 브라우저 상에서 나타나는 마운트 시점입니다.
        두번째는 컴포넌트의 props, state, 부모 컴포넌트의 변화에 따른 업데이트 시점입니다.
        마지막으로 컴포넌트가 DOM 에서 제거되는 언마운트 시점이 있습니다.
        개발자들은 라이프 사이클 메서드를 사용해 각 시점에 맞는 로직들을 정의할 수 있습니다.
        
    - 오경민
        
        라이프사이클은 컴포넌트가 브라우저 상에 나타나고, 업데이트되고, 사라지게 되는 과정이다. 컴포넌트의 수명은 보통 페이지에서 렌더링되기 전인 준비 과정에서 시작하여 페이지에서 사라질때 끝이 납니다.
        라이프사이클은 메서드들을 통해 각 단계에 맞는 기능을 수행합니다.
        
    - 김섭찬
        
        라이프사이클(Lifecycle)은 컴포넌트나 객체가 생성되어 사용되고 파괴될 때까지의 일련의 과정을 의미합니다. React 컴포넌트의 라이프사이클은 크게 마운팅, 업데이트, 언마운팅의 세 단계로 나뉘며, 각 단계에서 호출되는 여러 라이프사이클 메서드가 있습니다. 이러한 메서드를 통해 컴포넌트의 상태를 관리하고, 부가적인 작업을 수행하며, 필요한 정리 작업을 할 수 있습니다. 라이프사이클을 이해하고 적절히 사용하는 것은 React 애플리케이션을 효율적이고 유지보수하기 쉽게 만드는 데 중요한 역할을 합니다.
        
    - 이지혜
        
        라이프사이클은 컴포넌트가 생성되고, 업데이트되며 제거되는 과정 전체를 의미합니다.
        
        컴포넌트는 일반적으로 생성 > 마운트 > 업데이트 > 언마운트의 과정을 거칩니다. 
        
        라이프 사이클은 컴포넌트가 어떻게 동작하고 언제 어떤 작업을 수행하는지 이해하는데 중요합니다. 
        
        초가 데이터를 가져오거나 DOM과 같은 작업은 마운트, 컴포넌트가 업데이트 된 후 추가 작업을 수행할 때는 업데이트, 불필요한 리소스를 정리할 때는 언마운트 에서 수행하는 것이 적절합니다. 
        
        **hook에서 의 대응**
        
        useEffect를 사용해서 라이프사이클과 유사한 작업을 할 수 있음 
        
        setup으로 마운트, 의존성 배열로 업데이트, 클립업 함수로 언마운트
        
        하지만 라이프사이클과 완전히 동일한 것은 아님
        
    - **❓ 꼬리질문**
        
        함수형 컴포넌트에서 라이프사이클 메서드를 사용했을 때 느꼈던 장/단점이 있나요?
        
        class 컴포넌트의 라이프사이클 메서드(componentDidMount, Update, willUnmount)를 함수형 컴포넌트에 사용한다면 어떻게 사용할 수 있을까요?
        

🔥 **피드백(22~24)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 전체적인 답변을 잘 간추려서 말씀해 주셔서 루즈한 느낌이 없어 좋았습니다.
     | 22.
    - 핵심 내용이라고 생각할 수 있는 DOM에 대한 내용을 우선 강조해서 설명해주신 부분이 좋았습니다. |
    | 개선사항 | [주관적]
    23.
    꼬리질문으로 드렸었던 얖은 복사와 깊은 복사의 차이를 혜찬님께서 얖은 비교와 깊은 비교로 이해하고 답변하신거 같았습니다. 이렇게 헷갈릴 수 있는 비슷한 키워드 질문 같은 경우 한번더 짚고 넘어가도 좋을 것 같습니다.
     | [주관적]
    - 바닐라js대신 react를 사용하는 이유 or 장점을 얘기한다면
    바닐라JS에서는 불가능한건지, 아니면 React에서 좀 더 효율적이라 좋은지 간단하게 알아두면 더 좋을 것 같습니다. |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 23. 다양한 장점 중 필요한 내용만 잘 압축해서 말씀해주셔서 좋았습니다. | 22번 외에 전반적으로 중요한 내용만 잘 요약해서 설명해주신 것 같아 좋았습니다. |
    | 개선사항 | 22.
    설명이 한 분야에 특화되어 길게 설명되어있어 시니어 면접관 입장에서는 다른 질문을 할 확률이 높아보입니다. | 22.
    - React를 사용하는 이유 중 DOM에 관련한 부분만 말씀해주신 부분은 듣기에 따라 핵심 키워드에 대한 언급이 부족하다고 생각될 수 있을 것 같습니다.
    
     |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 각 문제에 대해서 자세한 설명보다는 항목별로 최대한 간단하게 설명하는것이 면접자 기준에서 좋았다고 생각합니다. | 각 문제에 대해 필요한 키워드를 넣어서 잘 말씀해 주셨습니다. 22 번 질문에서 본인의 생각을 묻는 질문에서도 자신만의 생각을 잘 말씀해 주셔서 좋았습니다. |
    | 개선사항 | 23.
    불변성의 다양한 장점중에 프론트가 아닌 다른 영역에 해당되는 장점들까지 포함하는 경우, 정확히 알지못하면 마이너스가 될 수 있다고 생각합니다.
    24.
    꼬리질문 답변에서 질문의 의도를 살짝 벗어난 답변을 하신 것 같았습니다. | 전체적인 답변길이가 적당하고 좋았습니다. 
    [주관적]개인적으로 24번 질문에서 클래스, 함수형 컴포넌트를 비교해서 메서드를 설명해 주실 때, 함수형에서 useEffect를 언급해주시면서 답을 해주셨으면 더 좋았을 것 같다는 아쉬움이 있었습니다. |
    
- 이지혜
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 두 문제 모두 최대한 요약하면서 필요한 내용들이 들어가 있어서 좋았습니다. | 24번 질문. 답변과 꼬리질문까지 답변을 잘해주셨습니다. |
    | 개선사항 | 22. 중간에 훅 이름에 useState 를 useStatus 라고 말씀을 하셔서 용어적인 부분에 조금 더 주의해주시면 될 것 같습니다. | 24번 질문에서는 크게 피드백 드릴 내용이 없는 것 같습니다. 잘 설명해 주셨습니다. |

---

25. 라이프사이클 메소드에 대해 설명해주세요.
    
    참고자료 : https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
    
    ✅ **답변**
    
    - 방혜찬
        
        라이프 사이클 메서드는 대표적인 3가지 시점의 전후를 기준으로 존재합니다
        마운트되기 전에는 constructor 메서드를 사용하여 컴포넌트의 state 를 초기화하고, 이벤트 핸들러를 바인딩합니다.
        이후 DOM 에 컴포넌트가 렌더된 후에는 componentDidMount 메서드로 데이터 요청 등의 네트워크 요청을 처리합니다.
        이후 변화로 인한 리렌더가 실행되면 DOM 이 업데이트 된 후에는 componentDidupdate 메서드를 사용하여 변화에 따른 네트워크 요청을 보내는 작업을 처리합니다.
        마지막으로 DOM 에서 컴포넌트가 제거되기 직전에는 componentWillUnmount 메서드를 사용하여 타이머와 네트워크 요청, 바인딩한 이벤트 핸들러 등을 제거합니다.
        
        클래스 컴포넌트의 **constructor** 에서  이벤트 핸들러 바인딩 시 함수 표현식 형태로 선언되지 않은 이벤트 핸들러에 this 를 바인딩 시켜줘야 핸들러 내부에서 컴포넌트의 this 를 사용할 수 있다.
        this.handleClick = this.handleClick.bind(this);
        constructor 가 아닌 **componentDidMount** 에서 setState 로 state 초기화가 가능하긴 한데, 이러면 render 가 두번 호출되어 성능이슈가 생길 수 있다.(사용자는 못봄)
        리렌더는 props 변화, state 변화, 강제 발동으로 발생가능.
        **componentDidUpdate** 에서 **이전 props, state, snapshot** 을 가져와 사용가능.
        **getDerivedStateFromProps** 는 mount, update 시점에서 render 메서드를 호출하기 직전에 호출되는데,  props에 state가 의존하는 아주 드문 경우에 사용합니다. 예를 들어, <Transition>와 같은 컴포넌트를 구현할 때 무엇을 움직이도록 만들지 결정하기 위해 이전과 현재의 자식 엘리먼트를 비교하는 경우 편리하게 사용할 수 있습니다.
        **shouldComponentUpdate** 는 업데이트 시점에서 getDerivedStateFromProps 메서드 보다 먼저 실행됩니다. state 또는 props의 변화를 렌더링에 적용할건지 true 혹은 false 를 적용해 결정할 수 있습니다. 기본값은 true 이고 forceUpdate 메서드로 강제 리렌더링 하는 경우 호출되지 않습니다.
        this.props, this.state 와 메서드 인자로 전달받은 nextProps, nextState 를 비교할 수 있습니다. 단순히 리렌더링을 막기위해 사용하면 안되고 성능 최적화를 위해 사용해야 합니다.
        https://ko.legacy.reactjs.org/docs/optimizing-performance.html
        그 외에도 에러바운더리 컴포넌트에서 **componentDidCatch** 메서드로 에러객체를 사용하거나 에러페이지를 렌더링할 수 있습니다.
        
    - 오경민
        
        라이프사이클은 마운트, 업데이트, 언마운트 세 단계로 진행됩니다. 마운트 단계에서는 컴포넌트가 새로 생성될 때마다 호출되는 constructor 메서드가 호출됩니다. 그다음 준비된 ui를 렌더링 하는 렌더 메서드가 실행되고 첫 번째 렌더링 후 componentDidMount 메서드가 호출됩니다.
        
        업데이트 변화가 발생했을 때 render 메서드를 통해 리렌더링 합니다. 그 다음 컴포넌트 변화를 dom에 반영하기 전 getSnapshotBeforeUpdate() 메서드를 호출하고, 마지막으로 업데이트가 끝나면 componentDidUpdate 메서드가 호출됩니다.
        
        언마운트 단계에서는 컴포넌트가 화면에서 사라지기 전 componentWillUnmount() 메서드가 호출됩니다.
        
    - 김섭찬
        
        React 라이프사이클 메소드는 컴포넌트가 생성, 업데이트, 파괴될 때 호출되는 메소드로, 컴포넌트의 상태를 관리하고 부가적인 작업을 수행하는 데 사용됩니다. 클래스형 컴포넌트에서는 마운팅(Mounting), 업데이트(Updating), 언마운팅(Unmounting)의 세 단계로 나뉩니다.
        마운팅 단계는 constructor, render, componentDidMount
        업데이트는  shouldComponentUpdate, componentDidUpdate
        언마운팅 componentWillUnmount 등의 메소드를 사용하며, 함수형 컴포넌트에서는 주로 useEffect Hook을 사용하여 동일한 기능을 구현합니다.
        
        useEffect의 빈 의존성 배열의 함수 본문은 componentDidMount와 비슷하고, return부분은 componentWillUnmount와 비슷하고, 의존성 배열이 있는 함수의 본문은 componentDidUpdate와 비슷합니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        클래스형과 함수형 라이프사이클의 차이를 실제 라이프사이클 메서드를 활용해 설명해주세요
        
        함수형 컴포넌트의 장점들이 발휘되는 부분이 뭘까요?
        
        라이프사이클 메서드 별 대표적인 사용용도를 간단하게 말해주세요
        
26. react 클래스형과 함수형의 차이를 설명해주세요. 어떤 방식을 주로 사용하였고 그 이유가 뭔지 답변해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        클래스형 컴포넌트는 React의 Component 클래스를 상속받아서 정의하는데, 다양한 라이프사이클 메서드를 상속받아 사용할 수 있기 때문에, 함수형 컴포넌트보다 상세한 라이프사이클 설정이 가능합니다.
        다만 클래스형 컴포넌트는 메서드에서 상태를 참조하기 위해 this 를 직접 바인딩 시켜주거나, 함수 표현식으로 정의해야하는 불편함이 있습니다.
        함수형 컴포넌트는 화살표 함수나 일반 함수로 정의하는데, 상속을 받지 않기 때문에 상태나 라이프 사이클, 메서드는 리액트에서 제공하는 훅을 사용하여 관리할 수 있습니다.
        컴포넌트 뷰에 관련된 코드는 return 구문에 작성하는데, 이러한 코드 구조는 클래스형에 비해 직관적이고 간결하기 때문에 가독성이 좋다는 장점이 있습니다.
        
        클래스형은 인스턴스 생성 과정이 필요하고 사용하지 않는 메서드나 속성도 같이 상속되기 때문에 메모리 사용량이 더 많아집니다.
        함수형의 useEffect 훅은 componentDidMount, ComponentDidUpdate, componentWillUnMount 시점을 합친것으로 첫번째 파라미터(setup)에 라이프 사이클 메서드의 실제 로직 작성하고, 두번째 파라미터에 update 라이프사이클을 위한 의존성들을 배열형태로 넣습니다. 만약 없으면 mount 뒤에만 실행한다. 셋업 함수에 리턴 구문에 컴포넌트 언마운트 전 실행할 로직을 작성합니다.
        
    - 오경민
        
        클래스형 컴포넌트는 라이프사이클 메서드를 사용해 컴포넌트 생명주기를 관리합니다. 리액트 컴포넌트의 속성이나 상태에 접근하기 위해 this키워드를 사용합니다. 함수형 컴포넌트는 일반 함수나 화살표 함수를 사용합니다. 클래스 컴포넌트와 다르게 react hook을 활용해 상태관리나, 라이프사이클 로직을 구현합니다.
        
        함수형 컴포넌트는 훅을 사용하기때문에 클래스형에 비해 코드가 간결하고 가독성이 더 좋다고 할 수 있습니다.
        
        그 중, 저는 주로 함수형컴포넌트로 개발을 해왔습니다. 훅을 활용해 코드를 쉽고 더 효율적으로 작성할 수 있었고, 팀 단위로 개발을 하게되면 코드의 가독성이 더 중요하다고 생각하기 때문에 이미 클래스형으로 구성된 프로젝트에 참여하게 되거나 다른 특별한 상황이 아니라면 저는 계속 함수형 컴포넌트를 사용할 것 같습니다.
        
    - 김섭찬
        
        클래스형 컴포넌트는 ES6 클래스 문법을 사용하여 정의하고 render 메서드로 JSX를 반환합니다.
        상태관리의 경우 this.state와 this.setState를 사용하여 상태를 관리합니다그리고 컴포넌트의 여러 라이프사이클 메서드를 제공합니다. 
        함수형 컴포넌트는 JavaScript함수로 정의하고 함수의 반환값으로 JSX를 반환합니다.
        React 16.8 이후, useState와 같은 Hook을 사용해 상태를 관리합니다.
        클래스형 컴포넌트의 라이프사이클 메서드 대신, useEffect와 같은 Hook을 사용하여 생명 주기 동안 특정 시점에 작업을 수행할 수 있습니다.
        저는 프로젝트 개발 중 주로 함수형 컴포넌트를 사용했습니다.
        그 이유로는 코드의 간결성, Hook의 기능성, 순수 함수의 테스트 용이성, 클래스형 컴포넌트포다 가볍고 메모리 사용량이 적음으로서 생기는 성능 향상이 있습니다.
        추가적으로 최근 React자체도 함수형 컴포넌트와 Hook을 중심으로 새로운 기능이 개발되고 있어, 최신 React 기능을 사용하는데 유리한 점도 있습니다.
        - 추가: 다만 서비스 개발 중 여러 단계의 상태 변화가 연속적으로 일어나고, 각 단계에서 별도의 처리가 필요한 일부 화면의 경우, 클래스 컴포넌트의 라이프사이클 메서드를 사용해 개발했습니다.
        
    - 이지혜
        
        **클래스형 컴포넌트**와 **함수형 컴포넌트**는 React에서 컴포넌트를 작성하는 두 가지 방법입니다. 
        
        **클래스형 컴포넌트**는 class 키워드를 사용해 정의합니다. 
        
        라이프사이클 메서드를 사용해서 컴포넌트의 생명 주기를 관리할 수 있으며, React 컴포넌트의 속성과 상태에 접근하기 위해 this 키워드를 사용합니다. 
        
        **함수형 컴포넌트**는 function 키워드나 화살표 함수를 사용해 정의합니다. 
        
        `useState`, `useEffect`와 같은 훅을 통해 상태를 관리합니다. 클래스형에 비해 코드가 간결합니다. 
        
        기존에는 클래스 형으로 많이 작성되었으나 리액트 최신 버전에서 훅이 생겨난 이후부터는 함수형 컴포넌트를 사용하는 추세입니다.
        
        저 또한 코드가 간결하고 직관적인 함수형 컴포넌트를 주로 사용합니다.
        
    - **❓ 꼬리질문**
        
        함수형이 클래스형에 비해서 가지는 장점이 뭘까요?
        → 성능적인 측면은 클래스를 상속받지 않기 때문에 인스턴스 생성과정을 생략 해 더 빠르고 상속받는 메서드나 속성이 없어서 메모리 측면에서 더 효율적입니다
        
        클래스형 컴포넌트에서 메서드에 상태를 사용할 때 주의할 점이 뭘까요? → 클래스형 컴포넌트는 메서드에서 상태를 참조하기 위해 this 를 직접 바인딩 시켜주거나, 함수 표현식으로 정의해야 합니다.
        
27. Lazy loading 과 Code splitting 에 대해 아는 만큼 설명해주실 수 있을까요?
    
    ✅ **답변**
    
    - 방혜찬🔧
        
        먼저, lazy loading은 컴포넌트와 외부 리소스의 로딩을 최적화하여 성능을 최적화하는 기술입니다.
        페이지를 렌더링할 때 필요한 리소스만 로딩하고, 이후 이벤트가 발생하여 추가적인 렌더링이 필요해지면 이미지, 폰트 등 큰 용량의 리소스나 컴포넌트들을 동적으로 로딩하는 기술입니다.
        이를 통해 초기 로딩 속도를 향상시켜 사용자 경험을 개선할 수 있습니다.
        코드 분할은 불필요한 코드나 중복되는 코드를 최대한 없애고 필요한 시점에 로딩될 수 있도록 분리하는 기술입니다.
        대규모 프로젝트일수록 코드의 규모가 커지는데, 대표적으로 두가지 방식으로 코드를 분할할 수 있습니다.
        첫번째는 페이지 별로 코드를 분할하여, 해당 페이지에서 사용하는 코드들만 로딩하는 방식입니다.
        두번째는 페이지별로 공통적으로 사용되는 코드가 있고 그 사이즈가 클 경우, 하나의 모듈로 따로 분리해서 한번만 로딩하여 여러 페이지에 같이 사용하는 방식입니다.
        두가지 기술이 중점을 두는 기준에 차이가 있기 때문에 전반적인 성능 향상을 위해선 2가지 기술을 모두 사용하는 것이 일반적입니다.
        
    - 오경민
        
        lazyloading과 code splitting은  lazy loading은 로딩시점에 모든 리소스가 아닌 필요한 리소스만 동적으로 로딩하는 기술입니다.
        이로써 초기 로딩속도도 향상시킬 수있고, ux측면에서도 개선할 수 있습니다. 코드 스플리팅은 파일을 분리해서 사용자가 현재 필요로 하는 파일만 불러오는 작업을 의미합니다.
        
        리액트에서는 주로 React.lazy와 Suspense를 활용해서 간단하게 코드스플리팅을 할 수 있습니다.
        React.lazy는 컴포넌트를 렌더링하는 시점에서 비동기적으로 로딩할 수 있게 해 주는 유틸 함수 입니다.
        Suspense는 리액트 내장 컴포넌트로 코드 스플리팅된 컴포넌트를 로딩하도록 발동시킬 수 있고, 로딩이 끝나지 않았을 때 보여 줄 UI를 설정할 수 있습니다.
        
    - 김섭찬
        
        지연로딩은 필요한 시점까지 리소스의 로딩을 지연시키는 기술로, 초기 로딩 시간을 줄이고 네트워크 효율성을 높일 수 있습니다. 
        React에서는 React.lazy와 Suspense를 사용하여 구현할 수 있습니다.
        코드 분할은 애플리케이션의 코드를 여러 청크로 분할하여 필요한 코드만 로딩하는 기술입니다.
        Webpack과 같은 번들러를 사용하여 구현할 수 있으며, React에서는 동적 import()를 사용하여 코드 스플리팅을 구현할 수 있습니다.
        마지막으로 라우트 기반 코드 분할은 앱의 각 경로, 페이지를 기준으로 코드를 분할해, 해당 경로에 접근할 때만 필요한 코드를 로드하는 방법입니다.
        
    - 이지혜
        
        **Lazy Loading**과 **Code Splitting**은 웹 성능을 최적화하는 데 사용할 수 있는 기법입니다.
        
        **Lazy Loading**은 필요할 때까지 리소스를 로드하지 않는 기술입니다. 초기 로드 시 사용자가 필요로 하지 않는 리소스를 로드하지 않음으로써 초기 로딩 속도를 단축시킬 수 있습니다. 
        
        실제로 저는 비타 프로젝트를 진행하면서 `React.lazy()`와 `Suspense`를 적용하여  초기 로딩에 불필요한  전체 상품페이지, 유지, 어드민 페이지와 같은 페이지를 필요할 때만 로드하도록 구현하였고 이를 통해 초기 로딩 속도를 단축시킬 수 있었습니다. 
        
        **Code Splitting**은 애플리케이션의 코드 베이스를 여러 개의 작은 번들로 나누는 기술입니다. 모든 코드를 한꺼번에 로드하지 않고, 필요한 부분만 로드함으로써 페이지 로드 속도를 향상시킵니다.
        
        웹팩(Webpack)과 같은 번들러를 사용해 구현할 수 있으며, React에서는 `React.lazy()`와 `import()`를 통해 동적으로 모듈을 로드하는 방식으로 활용할 수 있습니다. 
        
        **lazy loading**은 주로 외부 리소스의 로딩을 최적화하고 **code splitting**은 애플리케이션의 자바스크립트 코드를 최적화하는데 중점을 둔다는 점에서 차이가 있습니다.
        
    - **❓ 꼬리질문**
        
        다른 최적화 기법을 사용하신 게 있나요?
        
        React 에서 제공하는 다른 최적화 방식은 뭐가 있나요?
        
        lazy loading 의 사용자 경험 측면에서 주의점이 있을까요? → 로딩할 페이지 구분, 로딩 상태 표기(Suspense)
        

🔥 **피드백(25~27)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 전체적인 질문에 대한 답변과 꼬리질문 답변까지 좋았습니다.
     | 25.
    - 중요하게 사용되는 메서드만 잘 얘기해주셔서 좋았습니다.
    
    25, 26 꼬리 질문에 대해서도 경험 기반으로 말씀해주시는 것이 알고 계신 지식에 대한 근거로 충분히 합당하게 받아들여졌습니다.
    
    오늘이 모의 면접 중 가장 좋았던 것 같습니다!! |
    | 개선사항 | 이 부분은 조금 애매할 수 있는데, 직접적인 지연로딩과 코드 분할을 적용해 보시진 않았더라도 리액트에서 어떻게 코드분할을 적용할 수 있는지에 대해서 간단하게 알고만 계셔도 더 좋을 것 같습니다. ( React.lazy , Suspense ) |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 25. 넓은 주제를 항목별로 단순화해서 좋았습니다.
     | 25. 
    - 라이프사이클 흐름을 기반으로 잘 답변해주셔서 좋았습니다.
    26.
    - 두 컴포넌트에 대해서 충분히 잘 설명된 것 같습니다 |
    | 개선사항 | 25. 리액트의 라이프사이클 메서드 중 많이 사용하지 않는 메서드들은 보통 도큐먼트에서 권장하는 사용 용도가 아니면 성능을 저하 시키는 사이드 이펙트가 커서 해당 메서드를 설명에 포함하실 때는 사용 용도를 파악하시는 게 좋을 것 같습니다. | 27.
    - 설명이 너무 많이 압축 된 느낌을 받았습니다. 핵심 키워드를 1,2개 더 선정해서 추가해주신다면 더 좋을 것 같습니다.
    - 꼬리질문에서 많이 당황신 모습이 보였습니다. 답변 내용은 좋았으니 좀 더 침착하게 말씀해주신다면 좋을 것 같습니다. |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 전체적으로 답변이 깔끔하고 퀄리티가 좋았습니다.
    25, 26. 꼬리질문도 경험을 활용해 잘 답변해주셔서 좋았습니다.
     | 답변이 아주 좋았습니다. 실제 경험 사례로 추가적인 예시까지 좋았습니다. 
    전체적으로 꼬리질문에 대해서도 잘 대답해 주셔서 잘 이해하고 있는 듯한 느낌이 들어서 좋았습니다. |
    | 개선사항 | 특별히 고쳐야할 부분은 찾지 못했습니다. | 오늘은 전체적으로 크게 보완해야 할 부분은 못느꼈습니다. 좋았습니다. |
    
- 이지혜
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 방대한 내용의 요약과 본인의 경험 사례를 같이 설명해주셔서 더 좋았습니다. | 실제 경험 사례를 잘 설명해 주셔서 좋았습니다. 설명해주실 때, 수치화까지 해주시면 더 좋을듯 ! |
    | 개선사항 | 용어를 잘못 말씀하셨을 때, 가볍게 정정하시고 다시 말씀하셔도 좋을 것 같습니다.
    최적화 사례는 수치까지 같이 포함해서 말씀해주시면 어필이 더 잘 될 것 같습니다. | 질문이 이해가 안가는 경우, 되물어 보실 때 ~~거죠? 라는 질문보단 조금 더 정중한 표현으로 ~~라고 여쭤보신게 맞을까요? 이런 느낌으로 개선해보면 더 좋을 것 같습니다. |

---

28. Event bubbling 과 capturing 을 비교하여 설명해주실 수 있을까요?
    
    ✅ **답변**
    
    - 방혜찬
        
        이벤트 버블링은 이벤트가 발생했을 때, 타겟 엘레멘트부터 최상위 엘레멘트인 window 까지 순서대로 전파되는 방식을 말합니다. 브라우저에서 기본적인 이벤트 전파 방식으로 버블링 방식을 사용하기 때문에, 부모 요소에도 동일 이벤트에 대한 리스너가 있다면 필요에 따라 전파를 방지하는 작업이 필요합니다.
        이벤트 캡쳐링은 이벤트가 발생했을 때, 최상위 일레멘트 window 부터 타겟 엘레멘트까지 순서대로 전파되는 방식을 말합니다. 캡처링 방식을 사용해 상위 요소들의 이벤트 리스너를 먼저 동작시키려면 별도의 설정이 필요합니다.
        
        전파 막기 : event객체.stopPropagation,
        w3c 에서 선택된 이벤트 전파 방식(돔 레벨 2?)은 기본적으로 이벤트 발생 시 캡처링형식으로 window 부터 타겟 엘레멘트까지 캡처링 후, 다시 window 까지 버블링되는 방식입니다.
        브라우저에서는 이벤트가 버블링 방식으로 타겟 엘레멘트부터 window 까지 버블링하며 등록된 이벤트 리스너들을 순차적으로 실행합니다.
        돔 레벨 : https://jopemachine.github.io/2021/10/10/Dom-Level/
        `이벤트 위임` 이란 버블링에 의해 document 레벨까지 버블링 되어 올라가는데 자식 엘리먼트의 하나하나에 모든 이벤트를 주는 것이 아닌 부모에게만 이벤트를 위임하는 방법입니다.
        
    - 오경민
        
        이벤트 버블링은 이벤트가 발생한 요소에서 상위 요소로 이벤트가 전파되는 방식입니다.
        이벤트 캡처링은 최상위 요소에서 이벤트가 발생한 요소까지 내려오는 방식입니다.
        대부분의 이벤트는 버블링 방식이기 때문에 캡처링을 사용하기 위해선 addeventlistener 옵션으로 capture를 넣어서 사용할 수있습니다.
        
    - 김섭찬
        
        이벤트 버블링(Event Bubbling)과 캡쳐링(Event Capturing)은 웹 브라우저에서 이벤트가 DOM 요소 간에 어떻게 전파되는지 정의하는 두 가지 방식입니다.
        이벤트 버블링은 이벤트가 가장 안쪽의 요소에서 시작하여 부모 요소로 전파되고, 해당 요소의 가장 바깥쪽, 최상위 요소(document)까지 전파됩니다.
        기본적으로 대부분의 이벤트는 버블링을 통해 전파됩니다.
        
        이벤트 캡쳐링은 이벤트가 가장 바깥쪽, 최상위 요소(document)에서부터 시작하여 점점 안쪽 요소로 전파되는 방식입니다. 기본적으로 사용되지 않지만, 필요에 따라 캡쳐링 단계에서 이벤트를 처리할 수 있습니다. 이벤트 리스너를 등록할 때 세 번째 인자로 true를 전달하면 됩니다.
        
    - 이지혜
        
        **Event Bubbling**과 **Event Capturing**은 이벤트가 발생했을 때 DOM 요소에서 이벤트가 전파되는 방식입니다. 
        
        이벤트 버블링은 이벤트가 상향식으로 전파되는 방식으로, 자식 요소에서 클릭 이벤트가 발생하면 그 이벤트가 부모 요소에까지 전달됩니다. 
        
        이벤트 캡처링은 버블링과 반대로 하양식으로 전파되는 방식입니다. 
        
        대부분의 브라우저는 기본적으로 버블링을 사용하며, 별도의 설정을 통해 캡처링을 발생시킬 수 있습니다. 
        
    - **❓ 꼬리질문**
        
        부모 이벤트 전파 방지 작업은 어떻게 하나요?
        
        전파 방지는 왜 필요한가요?
        
        캡쳐링를 적용하기 위한 별도의 설정은 어떻게 할 수 있나요?
        
        이벤트 버블링을 좀 더 효율적으로 사용할 수있는 방법에 대해 아시나요 ?
        (이벤트 위임에 대해 묻는 질문)
        
        브라우저에서 이벤트 전파의 전체적인 흐름은 어떻게될까요?
        최상위(캡처링) → 타겟엘레멘트(버블링) → 최상위
        
29. 자바스크립트와 타입스크립트의 차이, 장/단점에 대해 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        자바스크립트와 타입스크립트는 크게 두가지 차이점이 있습니다.
        첫번째 차이점은 타입 시스템입니다. 자바 스크립트는 변수의 타입이 런타임에 동적으로 결정되고, 타입스크립트는 개발자가 코드 내에서 변수의 타입까지 직접 작성하여 결정합니다.
        두번째 차이점은 컴파일 과정입니다. 결국 실행되는 코드는 자바 스크립트 코드이기 때문에, 타입스크립트는 작성된 내용을 자바스크립트 코드로 바꾸는 컴파일 과정을 거칩니다.
        
        자바스크립트의 장점은 타입 설정에 대한 학습이 따로 필요없기 때문에, 학습 난이도가 상대적으로 낮은 편입니다. 하지만 타입과 관련된 오류 확인은 런타임에서만 가능하기 때문에, 오류가 발생할 확률이 높다는 단점이 있습니다.
        타입스크립트의 장점은 타입 선언을 통한 방대한 코드의 타입 안정성을 간단하게 확보할 수 있다는 점입니다. 하지만 타입과 컴파일에 관련된 추가적인 학습이 필요하고, 컴파일 작업에 추가적인 시간이 소모된다는 단점과 타입 에러를 제외한 자바스크립트 자체의 에러는 해결할 수 없다는 단점이 있습니다.
        
        컴파일러는 프로그래밍 언어 전체를 기계어로 인터프리터는 컴파일하지 않고 한 줄씩 읽어서 실행
        
    - 오경민
        
        자바스크립트와 타입스크립트 차이점은 크게 2가지로 나눌수있습니다.
        첫번째는 타입 유무입니다. 자바스크립트에서 변수 타입은 런타임에 결정되고, 타입스크립트에서는 변수 타입을 선언하고 컴파일 과정에서 타입을 검사합니다.
        두번째는 컴파일 과정입니다.
        js는 별도의 컴파일 과정이 없어 직접 브라우저에서 실행되고, 타입스크립트는 컴파일러를 통해 js코드로 변환되어 실행됩니다.
        
        각각의 장단점으로는 자바스크립트는 변수의 타입을 런타임에 결정하기 때문에 코드 작성이 사전에 오류를 놓칠 수 있다는 단점이 있습니다.
        
        타입스크립트는 변수의 타입을 미리 선언하고 컴파일러가 이를 검사하므로 런타임 이전에 타입 오류를 발견할 수 있고 코드의 안정성을 높일 수 있다는 장점이 있습니다.
        컴파일 단계를 거쳐 자바스크립트 코드로 변환되어야 하기 때문에 추가 작업이 필요하다는 단점이 있습니다.
        
    - 김섭찬
        
        가장 큰 차이점은 JS는 동적 타입언어고, TS는 정적 타입 언어라는 점입니다.
        
        JS의 장점은 변수의 타입을 명시하지 않고, 런타임에 타입이 결정됩니다. 타입을 명시할 필요가 없으므로, 코드를 빠르게 작성하고 테스트할 수 있습니다.
        단점은 동적 타입으로 인해, 타입 관련 오류가 런타임에서 발견될 수 있어, 디버깅이 어려울 수 있고, 타입을 명시하지 않기 때문에, 코드의 구조와 의도를 이해하기 어려울 수 있습니다.
        반대로 TS는 컴파일 시 타입 오류를 검출하여, 런타임 에러를 줄이고, 코드의 안정성을 높입니다. 타입 정보를 바탕으로, 코드 자동 완성, 리팩토링, 오류 검출 기능이 향상됩니다.
        단점은 정적 타입 시스템과 TypeScript의 문법을 배우는 소요가 있습니다. 타입 정의와 컴파일 단계가 추가되어 초기 개발 속도가 느려질 수 있습니다. TypeScript 코드를 JavaScript로 트랜스파일링하는 추가 단계가 필요합니다.
        대규모 프로젝트나 코드의 안정성이 중요한 경우 TypeScript를 사용하는 것이 좋으며, 빠른 개발과 간편한 코드 작성을 원할 경우 JavaScript를 사용할 수 있습니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        TS도 서버 개발에 사용할 수 있나요?
        
        컴파일과 런타임이 무엇인가요?
        
        타입스크립트가 컴파일과정에서 모든 에러를 다 방지할 수 있을까요?
        
        인터페이스와 타입의 차이점을 아시나요?
        
30. 프론트엔드 성능최적화를 위한 방법이 있다면 말씀해주시고 그 중 프로젝트에서 활용한 경험이 있다면 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        프론트엔드 성능 최적화 방법은 대용량의 정적 리소스들의 크기 압축, 레이지 로딩을 활용한 초기 로딩속도 개선, 코드 스플리팅을 통해 번들 파일의 축소, 캐싱을 통한 네트워크 비용 절감 및 응답 속도 향상 등이 있습니다.
        제 프로젝트에서는 압축된 폰트 형식인 woff2 를 사용하여 폰트 용량을 70% 정도 용량을 줄일 수 있었습니다. 이미지의 최적화와 레이지 로딩을 위해서는 Next.js 에서 제공하는 Image 컴포넌트를 사용했습니다. 마지막으로 코드 스플리팅을 위해서 Next.js 를 활용해 페이지 기반의 코드 스플리팅을 진행했습니다.
        
        대용량의 정적 리소스들의 크기를 압축하는 방식은 이미지의 최적화나 압축된 폰트를 사용하는 방법 등이 대표적입니다.
        레이지 로딩을 활용한 초기 로딩속도 개선은 첫 렌더링에서 화면 내에 존재하는 요소들만 렌더링하고 그 뒤의 요소들은 유저 인터랙션에 따라 추가 렌더링을 진행하는 방식이 대표적입니다.
        코드 스플리팅을 통해 번들 파일의 축소는 페이지 단위로 스크립트 코드를 분리하고, 공통된 스크립트를 모듈 단위로 분리하는 방식이 대표적입니다.
        캐싱을 통한 네트워크 비용 절감 및 응답 속도 향상은 서버에 동일한 데이터를 다시 요청할 경우, 캐시된 데이터를 사용하는 방식이 대표적입니다.
        
    - 오경민
        
        프론트엔드에서 성능최적화에는 코드 분할 활용한 기 로딩 시간 줄이기, 이미지 포맷 최적화를 통해 성능 향상, 중복되는 리 렌더링 방지를 통해 성능 향상, 리소스 관리 등 여러 방법이 있습니다.
        
        저는 그중, 이미지 최적화와, 리소스 관리를 통해 성능을 개선해 본 경험이 있습니다. 진행했던 프로젝트 특성상 고화질의 jpg형식의 이미지가 많이 사용되었습니다. 이는 라이트하우스 LCP 항목에서 안좋은 점수를 받았고, 화질은 최대한 유지하면서 파일 크기를 줄일 수 있도록 webp 방식을 사용하였습니다.
        
        또한, 사용자가 페이지에 접속할 때마다 매번 api를 호출하는 걸 방지하기 위해 react-query의 staletime과 cachetime 을 통해 캐싱처리를 해주었습니다. 이로써 실제로 기존 4초가 걸리던 렌더링 속도를 1.2초까지 낮출 수 있었고, 라이트하우스 퍼포먼스 부분에서도 기존 58점에서 93점까지 개선할 수 있었습니다.
        
    - 김섭찬
        
        최적화 방법으로는 코드 분할, 지연로딩, 이미지 최적화, 캐싱, 코드 압축, 서버 사이드 렌더링, 프리로딩 및 프리페칭 등이 있는 것으로 알고있습니다.
        React 프로젝트에는 지연로딩, 코드 분할을 적용했었고, Next.js를 사용하여 서버 사이드 렌더링을 구현했습니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        싱글페이지에 어떻게 SEO를 적용하셨나요?
        
        성능 최적화 과정에서 성능 측정은 어떻게 하셨나요?
        

🔥 **피드백(28~30)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 28번 질문같은 경우 버블링 캡처링에 대해 잘 설명해 주셨고, 전파 방지가 왜 필요한지에 대해 본인만의 생각을 잘 말씀해 주셔서 좋았습니다.
    
    29번 질문도 전체적인 답변은 잘 해주셨습니다.
    
    30번 질문도 본인 경험을 잘 말씀해 주셔서 좋았습니다. | 오늘은 전반적인 내용이 충분히 좋았고, 꼬리 질문에 대한 답변도 잘 설명해주신 점 좋았습니다. |
    | 개선사항 | 29번 질문. 타입스크립트를 서버에서 사용할 수 없다. 이 부분은 개선하면 더 좋을 것같습니다. "타입스크립트를 의도를 파악하기 위해 사용한다." 이 부분은 조금 애매한 것 같습니다. 과감하게 빼버리셔도 충분히 좋은 답변이 될 것 같습니다.
    
    30번 질문. "Next.js를 사용했는데 SSR은 적용을 안했다." 이 멘트를 처음 들으면 면접관 입장에서 신뢰도가 떨어질 수 있을 것 같습니다. 추후 공부 목적으로 사용해 보셨다고 하셨는데, 이 멘트를 앞에서 미리 설명해 주셨으면 면접관 입장에서 그걸 감안해서 들었을 텐데, 나중에 말씀해 주셔서 조금 헷갈렸습니다. 이 부분도 한번 고민해 보시면 좋을 것 같습니다. | 28.
    - 꼬리 질문에서 한 번 정도는 질문에 대해 잘못 이해한 부분을 수정하는 것이 괜찮으나, 여러번 반복된다면 면접에 집중하지 않고있다고 생각이 들 수도 있을 것 같아 좀 더 질문을 곱씹어본 후 천천히 답변해주신다면 더 좋을 것 같습니다
    
    29. 
    - JS 장점 중 서버 클라이언트가 같은 언어를 사용할 수 있다 라는 내용에서 TS도 서버 개발이 가능한지 알고 있거나, 모르더라도 둘의 차이를 이해하고 있다면 맞는 답변이 나와야할 것 같습니다.
    - TS 설명 중 코드의 의도를 명확히 확인할 수 있다는 부분은 명확한 예시가 없다면 과감히 빼셔도 좋을 것 같습니다.
    
    30. 
    - Next.js를 사용했는데 SSR을 적용하지 않았다면 면접관 입장에서는 의문이 들 수 있을 것 같아 적절한 답변 준비가 필요할 것 같습니다. |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 28 ~ 30. 순차적으로 구조화해서 설명과 차이점을 짚어주는게 좋았습니다.
    29. 에러 방지 예시에 대한 꼬리질문도 잘 답변해주셨습니다.
    꼬리 질문 답변도 본인 경험과 지식을 기반으로 잘 답변해주셨습니다. | 28.
    - 기본적인 설명과 꼬리 질문을 명확하게 되질문하고 답변하는 부분이 좋았습니다.
    29.
    - 역시 기본적인 설명이 충분히 이루어졌고, 꼬리 질문에 타입가드, 타입 내로잉까지 언급해주신 부분도 좋았습니다.
    30.
    - 기본적인 설명 좋았고, 라이트하우스 사용했던 내용, webp, reactQuery사용 등 경험 말해주신 내용 좋았고, 구체적인 시간 수치까지 언급해주신 점 좋았습니다 |
    | 개선사항 | 개선 X 추천 O
    29. 타입스크립트 컴파일러가 자바스크립트의 고질적 에러는 막지 못한다는 부분을 어필하면 있어 보이지 않을까요?
    - 주관적 - | 오늘은 특별한 개선 사항은 없습니다!! |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 28, 29 모두 구조화된 좋은 답변이었습니다.
    30. 방대한 최적화 방식들을 최대한 압축해서 최적화 방식만 짚어서 설명해주셔서 아주 좋았습니다.
    최적화 경험도 자세히 설명해주셔서 좋았습니다. | 28, 29 번 질문같은 경우 답변을 아주 잘해 주셨습니다.
    
    - 추가질문(컴파일, 런타임)에 대해서도 사실 모두가 알고는 있는 단어지만 갑자기 질문이 들어왔을 때, 머리가 하얘질 수 있는데 이에 대해서도 아주 잘 설명해 주셨습니다.
    
    30 번 질문 같은 경우도 본인 경험을 살려서 잘 설명해 주셨습니다. |
    | 개선사항 | 발견하지 못했습니다. 굿입니다. | 딱히 문제점은 없었습니다. 아주 좋았습니다. |
    
- 이지혜
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 적절한 설명과 더불어 본인의 경험도 같이 얘기해주신 부분과 꼬리질문에도 잘 답변해주셔서 흠잡을데없었습니다.  | 버블링과 캡처링에 대해서 간략해서 잘 말씀해 주셔서 좋았습니다. |
    | 개선사항 |  | 실제 적용 사례가 있냐라는 질문에서 조금 더 자세하게 설명해 주시면 좋았습니다. 어느 기능을 구현하면서 ~~ 이러한 상황에서 적용했다.  정도만 해주셔도 좋을 것 같습니다. |

---

31. Javascript의 event loop에 대해서 설명해주세요.
    
    ✅ **답변**
    
    - ❗️관련 자료❗️
        
        https://www.youtube.com/watch?v=YpQTeIqjC4o&t=17s
        
    - 방혜찬
        
        이벤트 루프는 자바스크립트 코드의 실행과 비동기 작업을 처리하는 런타임 모델로 크게 3가지 영역이 존재합니다.
        첫번째로 call stack 영역은 기본적인 코드의 실행을 담당합니다. 자바스크립트 코드가 하나씩 call stack 에 들어가서 실행되고 빠지고, 현재 코드의 실행이 완료되기 전까지는 다음 코드가 들어오지 못합니다.
        두번째로 heap 영역은 코드상에서 사용되는 객체들이 할당되는 메모리 영역입니다.
        마지막으로 Queue 영역은 이벤트나 타이머, 네트워크 요청 등 비동기 처리를 담당합니다. 비동기 기능들은 메인 쓰레드가 아닌 다른 쓰레드에서 실행되고, 결과를 처리하기 위해 설정한 콜백 함수가 Queue 영역에 순서대로 쌓이게 됩니다. 쌓인 콜백 함수들은 쌓인 순서대로 call stack 이 빌 때 가져와서 실행됩니다.
        
        만약 재귀적으로 함수를 호출하는 코드는, 현재 코드 위에 내부 함수 코드가 재귀적으로 쌓이게 되고, 나중에 쌓인 코드부터 순서대로 실행됩니다.
        큐는 3가지 macro task queue, micro task queue, animation frame queue. 우선순위는 micro 가 가장 높다. macro 는 task 를 하나만 빼서 실행하고 다음 루프로 넘어간다. micro 는 queue가 빌때까지 모두 처리하며, 우선순위가 높아 콜스택이 비자마자 가장 먼저 처리된다. animation 은 repaint 직전 queue 의 모든 task를 처리한다.
        
    - 오경민
        
        자바스크립트는 싱글스레드 언어이기 때문에 하나의 작업만 실행할 수 있는데요, 이벤트 루프는 자바스크립트에서 비동기 작업 처리를 위해 사용하는 매커니즘으로 볼 수 있습니다. 이벤트 루프는 콜스택과 콜백 큐를 감시하고, 콜 스택이 비어 있다면 콜백큐에 있는 작업을 콜 스택으로 이동시켜 실행합니다. 이로써 자바스크립트는 비동기 작업을 효율적으로 처리가능합니다.
        
    - 김섭찬
        
        js의 event loop는 비동기 작업을 처리하고 이벤트를 관리하는 매커니즘입니다. Call Stack, web APIs, Callback Queue, Event Loop라는 네 가지 요소로 구성됩니다. 먼저, Call Stack은 동기 함수 호출을 관리하는 곳입니다. 동기 함수가 호출되면 Call Stack에 쌓이고 실행됩니다.
        
        비동기 작업은 Web APIs로 보내집니다. 예를 들어 setTimeout 함수가 호출되면, 그 작업은 Web APIs로 전달되고 Call Stack에서 제거됩니다. Web APIs는 비동기 작업을 처리하고, 완료되면 그 결과를 Callback Queue로 보냅니다.
        
        Event Loop는 Call Stack과 Callback Queue를 지속적으로 확인합니다. Call Stack이 비어 있으면, Event Loop는 Callback Queue에서 대기 중인 콜백 함수를 Call Stack으로 이동시켜 실행합니다.
        
        이를 통해 JavaScript는 싱글 스레드 환경에서도 효율적으로 비동기 작업을 처리할 수 있습니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        콜백 큐와 마이크로 태스크 큐의 차이점은 무엇인가요 ?
        
        싱글 쓰레든데 비동기 처리는 어떻게 처리되는 걸까요?
        → 메인쓰레드가 아닌 다른 쓰레드에서처리됨
        
32. ContextAPI 란 무엇인가요?
    
    ✅ **답변**
    
    - 방혜찬
        
        context api 는 리액트에서 전역적으로 상태를 관리할 수 있도록 도와주는 도구입니다.
        props 를 통해서 상태를 공유하는 기존 방식은 공유하는 컴포넌트가 많을 수록 훨씬 불편해집니다. 이 때 특정 컴포넌트에 context api 를 사용하면 그 컴포넌트 내부의 모든 컴포넌트들이 같은 상태를 공유할 수 있습니다.
        createContext 메서드를 실행하여 context 객체를 생성할 수 있고, 생성된 객체 내부의 Provider 컴포넌트를 통해 상태값을 설정하고, Consumer 컴포넌트 혹은 useContext 메서드를 통해 설정된 상태값을 가져와서 사용할 수 있습니다.
        
        단점 1. **깊은 중첩 구조의 컴포넌트**에서 컨텍스트를 사용할 경우, 하위 컴포넌트가 상태값을 변경할 때마다 컨텍스트 전체가 리렌더링되기 때문에 성능 측면에서 치명적인 단점입니다. Redux와 같은 라이브러리는 상태 업데이트 시 필요한 부분만 리렌더링하도록 최적화되어 있습니다.
        2. 대규모 어플리케이션의 복잡한 상태관리가 필요한 경우 결국 컨텍스트를 분리해서 사용하기 때문에 관리가 쉽다는 장점을 잃어버립니다.
        3. redux devtools 같은 디버깅 도구 없이 직접 상태 변화 추적을 위해 로깅을 해야하는 불편함이 있습니다.
        
    - 오경민
        
        context api는 react에서 전역 상태관리를 위해 사용되는 api입니다. context api는 일반적으로 provider를 통해 저장된 데이터를 제공해 주고, 데이터를 사용하려는 컴포넌트에서 consumer를 사용해 데이터를 사용할 수 있습니다. provider와 consmuer를 사용하는 방법도 있지만, 함수형 컴포넌트에서는 useContext훅을 활용해 조금 더 간결한 코드로 context를 사용할 수도 있습니다.
        
        컴포넌트 구조가 단순하고  간단한 상태관리에는 가벼운 context api를 활용하는게  좋을 수 있지만, 비동기 작업같은 복잡한 로직 처리는 구현이 조금 까다롭다고 알고 있습니다.
        
    - 김섭찬
        
        Context API는 React에서 컴포넌트 트리 전체에 데이터를 효율적으로 공유하기 위한 방법입니다.
        장점은 Prop Drilling 방지, 전역 상태 관리의 장점이 있습니다.
        단점은 context의 값이 변경되면 해당 context를 구독하는 모든 컴포넌트가 리렌더링되는 성능 문제와
        작은 규모의 프로젝트에서는 Context API를 사용하는 것이 오히려 복잡성을 증가시킬 수 있다는 단점이 있습니다.
        
        사용법은 context를 생성하고, provider로 구독, consumer나 useContext로 context의 값을 읽어올 수 있습니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        redux 같은 전역 상태관리 라이브러리와 비교할 때 단점이 뭘까요?
        - 컴포넌트 트리 전체가 리렌더되는 성능 이슈
        - 복잡한 상태관리일 수록 분리해야 하기 때문에 본래 목적을 잃어버리는 단점
        - 디버깅 툴이 따로 없기 때문에 상태 추적을 위해 직접 로깅을 다 찍어줘야함
        
        Context API 의 Consumer 컴포넌트와 useContext 훅의 사용방법은 어떻게 다를까요?
        
33. 그렇다면 RESTful API를 개발한다고 했을 때 따라야할 원칙들을 몇가지만 설명해주시겠어요?
    
    ✅ **답변**
    
    - ❗️관련 자료❗️
        
        https://www.ibm.com/kr-ko/topics/rest-apis
        https://f-lab.kr/insight/hateoas-restful-api?gad_source=1&gclid=Cj0KCQjw4MSzBhC8ARIsAPFOuyX8Ht1W40tGBUIeNNu5VuQFEIbPSI4T43B5qmPuRdkzACuUqRAmg0saAjejEALw_wcB
        https://f-lab.kr/insight/understanding-restful-api-design-principles
        
    - 방혜찬
        
        RESTful API 의 목적은 이해하고 사용하기 쉬운 REST API 를 제공하는 것입니다.
        이를 위해 권장되는 몇가지 원칙이 있습니다.
        첫번째는 stateless 한 통신입니다. 클라이언트의 요청에는 서버에서 요청을 수행하기 위한 모든 정보를 포함하도록 하여 이전 통신에 의존하지 않도록 합니다.
        두번째는 명확하고 일관된 네이밍 규칙입니다. 요청에 관련된 URL 내의 path 에는 요청에 관련된 리소스를 명사형태로 정확히 명시하고, 처리 동작과 관련된 동사형태는 피합니다. 또 계층적인 path 구조로 관계를 표현할 수도 있습니다.
        마지막으로 표준 http 메서드와 상태 코드의 사용입니다. 특정 리소스에 관련된 여러가지 동작들을 구현할 때, 동작에 맞는 메서드로 분리하여 구현하면 요청의 기능이 명확해지고 유지보수의 복잡성을 크게 줄일 수 있습니다. 또한 응답 결과에도 HTTP 상태 코드를 활용하여 쉽게 알아볼 수 있게 하는것이 좋습니다.
        그 외에는 응답 데이터 캐싱을 통한 네트워크 트래픽 감소, HATEOAS(헤이티오스) 규칙을 준수하 클라이언트에게 다른 API 에 대한 정보를 제공하는 방법 등이 있습니다.
        
        위 규칙들은 권장되는 규칙이지 필수는 아닙니다. 예를들어 HTTP 메서드는 대표적으로 CRUD 메서드를 제공하기 때문에, 다른 서비스 로직을 처리하기엔 애매할 수 있습니다. 따라서 메서드를 억지로 끼워맞출 필요는 없습니다.
        캐시 : Cache-Control, ETag와 같은 캐시 관련 HTTP 헤더를 API 응답에 포함합니다. 리소스가 고유하고 일관된 URL을 갖도록 하여 클라이언트 캐시의 중복 항목 가능성을 줄입니다.
        헤이티오스 : 사용자의 상태에 따라 접근 가능한 API 요청 URL 을 링크 형태로 제공해주는 형식이 대표적입니다.
        
    - 오경민
        
        우선 Restful API는 REST원칙을 잘 따라서 개발한 API라고 표현할 수있는데, 이러한 설계를 위한 몇 가지 원칙이 있습니다.
        
        첫 번째는 리소스의 식별입니다. 모든 리소스는 고유한 URI를 가지고 이를 통해 리소스를 식별할기 때문에 일반적으로 동사보다는 명사로 표현해야 합니다.
        두번째는 리소스에 대한 연산을 명확하게 표현하기 위해  HTTP 메서드를 활용해야 한다는 점입니다.
        세번째는 클라이언트가 서버로부터 어떤 요청을 할 수 있는지를 서버의 응답을 통해 알 수 있어야 한다는 원칙입니다.
        
        이러한 원칙을 따라 설계한다면 RESTful API는 확장성, 유지보수성, 재사용성 등을 높일 수 있습니다.
        
    - 김섭찬
        
        RESTful API를 개발할 때 따라야할 6가지 설계 원칙이 있습니다. 균일한 인터페이스, 클라이언트-서버 분리, 무상태성, 캐시 가능성 알림, 계층화된 시스템 아키텍처, 선택 사항으로 코드 온디맨드 방식이 있습니다.
        
        추가 원칙으로는 HTTP 메서드, 상태코드 사용, 버전 관리, XML, JSON 등의 데이터 형식 명시 등이 있습니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        캐시 가능성 원칙은 무엇인가요?
        
        헤이티오스(HATEOAS)란 무엇인가요?
        
        URI와 URL은 어떻게 다른가요?
        

🔥 **피드백(31~33)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |  |
    | --- | --- | --- | --- |
    | 좋았던 점 | 31번 질문 - 콜 스택, 콜백 큐에 대해 잘 설명해 주셨습니다.
    
    32번 질문 - Context API에 대해 잘 설명해 주셨고, 꼬리질문에서 본인의 리덕스 사용경험까지 잘 설명해 주셔서 좋았습니다.
    
    33번 질문 - 설계 원칙과 설계원칙에 대해서 잘 설명해 주셨고, URI, URL 차이에 대해서도 잘 말씀해 주셨습니다. | 전반적인 답변이 좋았고, 꼬리 질문에 대한 준비도 충분히 되어있다고 생각했습니다.
    
    32번의 redux관련 꼬리 질문도 redux 사용 경험을 바탕으로 말씀해주셔서 좋은 답변이 된 것 같습니다.
    
    오늘 정말 준비가 잘 되셨다고 생각했습니다! |  |
    | 개선사항 | 크게 피드백할 부분은 없었던 것 같습니다.
    
    굳이 뽑자면 31번 질문 답변하실 때
     ‘런타임 모델’ 이라는 키워드가 들어가면 너무 문서를 읽는 듯한 느낌을 줄 수도 있을 것 같아서 과감하게 빼시고 매끄럽게 진행하시면 더 좋을 것 같습니다. | 33.
    - 서버 응답 리소스에 캐싱 허용여부에 대한 내용과 헤이티오스(HATEOAS)에 관한 키워드만 짧게 언급해주신다면 더 좋은 답변이 될 것 같습니다 |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 | 31. 원리적인 부분만 정말 간략해서 설명해주셔서 좋았습니다.
    꼬리질문도 잘 답변해주셨습니다.
    32. 설명과 사용방법을 압축해서 설명하여 내용이 간결했습니다.
    33. 본인이 중요하다 생각하는 항목을 추려서 설명해주신 것 같아 좋았습니다. | 31. 32.
    오늘 전체적인 답변의 내용이 핵심적인 내용만 잘 요약되어서 좋았습니다.
    
    31. 33
    꼬리 질문에 대한 답변이 잘 준비되어 잘 알고 있구나가 느껴졌습니다. |
    | 개선사항 | 32. useContext 의 역할을 물어봤을 때 잘 대답해주셔야 할 것 같습니다. | 32. provider를 감싸줘야 consumer, useContext 모두 사용이 가능하단 점을 모른다면 잘 모르고 있다는 생각이 들 것 같습니다.
    
    33. 서버 응답 리소스에 캐싱 허용여부에 대한 내용과 헤이티오스(HATEOAS)에 관한 키워드만 짧게 언급해주신다면 더 좋은 답변이 될 것 같습니다  |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 31. 전체 흐름을 항목별로 간단하고도 필요한 부분들만 잘 설명해주셨습니다.
    32. 개념 설명과 장단점을 빠르게 나열하며 설명하셔서 간결하고 듣기 좋았습니다.
    33. 다양한 원칙들을 간단하게 압축해주셨고, 꼬리질문도 잘 답변해주셨습니다. | 31번 질문 - 동작 과정 순서에 대해 잘 설명해 주셨습니다.
    
    32번 질문 - Context API가 무엇인지, 장단점에 대해서도 잘 말씀해 주셨습니다.
    
    33번 질문 - 말씀하신 설계 원칙과 각각의 원칙이 무엇인지에 대한 꼬리질문에서 상세한 설명까지 좋았습니다. |
    | 개선사항 | 31. 실제 Web API 의 비동기처리 질문은 메인쓰레드가 아닌 다른 쓰레드에서 처리된다 라고만 답변하시면 될 것 같습니다.
    32. 전역 상태관리 라이브러리와 비교하는 꼬리질문에는 성능 외적으로도 복잡해질수록 컨텍스트를 분리해야 해서 본래 목적을 상실한다, API 는 상태 변화 추적이 어렵다. 정도로 덧붙이면 더 어필이 되지 않을까 합니다. | 크게 피드백할 부분은 없었습니다.
    좋았습니다.
    
    굳이 고르자면 이벤트 루프에서 각 큐의 종류와 역할에 대해서 가볍게 알아두면 좋을 것 같습니다. |
    
- 이지혜
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 | 31. 이벤트 루프의 동작 방식을 따라 잘 설명해주셔서 좋았습니다.
     | 질문에 대한 피드백은 없는 것 같습니다. 워낙 잘 해주셔서 좋았습니다. 본인의 경험에 대해서도 잘 설명해 주신게 좋았습니다. |
    | 개선사항 | 31. WebAPI 의 경우 간단하게 Promise 나 setTimeout 같은 기능들을 말씀해주시면 좋을듯합니다. | 오늘은 크게 피드백 드릴 내용은 없는 것 같습니다. 너무 잘하셨습니다. |

---

## 🆕 새로 선정된 문제

1. 클로저란 무엇이고, 왜 사용하나요?
    
    ✅ **답변**
    
    - 방혜찬
        
        클로저는 함수가 선언될 때의 렉시컬 환경을 활용해서 지역 변수 뿐 아니라 외부 변수를 기억하고 계속 접근할 수 있는 함수를 뜻합니다.
        
        클로저는 주로 데이터 은닉과 상태 유지를 위해 사용합니다. 
        
        클로저를 사용하여 특정 데이터를 클로저 함수 내부에 선언하고 외부에서의 데이터 접근 범위를 제한할 수 있습니다.
        
        또한 특정 데이터를 스코프 내에서 계속 최신 상태로 유지하며 사용할 수 있습니다.
        
        ---
        
        - **렉시컬 환경**: 코드를 실행하기 앞서 생성되는 특별한 객체로, **실행할 스코프 범위 안에 있는 변수와 함수, 외부 스코프의 참조값을 저장한 객체**입니다. 실행 컨텍스트에 저장되어있습니다. 즉 우리가 소스 코드를 실행하면서 참조가 필요한 변수의 값을 이 Lexical Environment 라는 객체에서 식별자 이름을 키로 찾아냅니다.
        두가지 범위에
        - **데이터 은닉**: 클로저를 사용하여 특정 데이터를 함수 내부에 숨길 수 있습니다. 이를 통해 데이터의 접근 범위를 제한하고, 외부에서 데이터가 수정되는 것을 방지할 수 있습니다.
        - **상태 유지**: 클로저를 통해 함수 호출 간에 특정 상태를 유지할 수 있습니다. 예를 들어, 카운터를 구현할 때 유용합니다.
        
        **클로저를 사용할 때 주의할 점**은 메모리 관리입니다. 클로저는 참조하는 변수를 메모리에 유지하기 때문에, 이를 제대로 관리하지 않으면 메모리 누수가 발생할 수 있습니다. 따라서 클로저를 사용한 후에는 필요 없는 변수를 null로 설정하거나, 더 이상 필요 없는 경우 클로저를 삭제하여 메모리 해제를 명시적으로 해주는 것이 좋습니다.
        
        **실무에서** 클로저는 주로 이벤트 핸들러, 콜백 함수, 모듈 패턴에서 사용됩니다. 예를 들어, 자바스크립트 모듈 패턴을 통해 코드를 모듈화하고, 데이터를 은닉하는데 사용합니다
        
        클로저는 함수가 선언될 때의 렉시컬 환경(Lexical Environment)을 기억하기 때문에 생성됩니다. 자바스크립트 엔진은 함수를 정의할 때, 함수 내부에서 참조하는 외부 변수들을 기억합니다. 이 변수들은 함수가 실행된 이후에도 계속 접근할 수 있으며, 이것이 클로저를 가능하게 합니다. 이는 자바스크립트의 스코프 체인(Scope Chain)과 관련이 있습니다.
        
    - 오경민
        
        클로저란 함수가 선언될 때의 환경을 기억하는 함수입니다. 클로저는 함수가 나중에 다른 곳에서 호출되더라도, 선언된 시점의 변수들에 접근할 수 있게 하는 매커니즘입니다.
        클로저를 사용하는 이유는 첫번째로 상태유지입니다. 함수가 선언된 스코프의 변수를 기억하기 때문에, 상위 스코프 변수에 접근할 수 있게 되고, 접근한 변수는 외부함수와의 다른 스코프에 존재하기 때문에 최신 값을 유지할 수 있게 됩니다.
        두번째는 정보은닉입니다. 특정 변수나 함수를 외부에서 직접 접근할 수 없도록 감출 수 있기 때문에 이를 통해 중요한 데이터나 내부 로직을 외부에서 변경하려는 상황을 방지할 수 있습니다.
        마지막으로 전역변수 사용을 줄이수 있다는 장점인데 클로저를 사용하면 변수를 공유하는 특성은 유지하되 데이터를 은닉화할 수 있기 때문에, 전역 변수를 대체하여 안전한 코드를 작성할 수 있기 때문입니다..
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        - 클로저를 사용할 때 주의할점이 무엇일까요? → 클로저는 참조하는 변수를 메모리에 유지하기 때문에, 이를 제대로 관리하지 않으면 메모리 누수가 발생할 수 있습니다. 따라서 클로저를 사용한 후에는 필요 없는 변수를 null로 설정하거나, 더 이상 필요 없는 경우 클로저를 삭제하여 메모리 해제를 명시적으로 해주는 것이 좋습니다.
        
        1. 렉시컬 환경이란 무엇인가요?
            1. 렉시컬 환경을 구성하는 요소에 대해 설명해 주세요.
        2. 클로저의 활용 사례를 말씀해 주세요.
        
    
2. 프로세스와 쓰레드에 대해서 설명해주세요
    - ❗️관련 자료❗️
        
        https://inpa.tistory.com/entry/👩‍💻-프로세스-⚔️-쓰레드-차이#프로세스의_한계
        
    
    ✅ **답변**
    
    - 방혜찬
        
        **프로세스**란 운영 체제에서 실행 중인 프로그램을 의미합니다. 각 프로세스는 공유되지 않는 독립된 메모리 공간을 가집니다. 프로세스는 운영 체제의 기본 단위로, 실행 파일과 관련된 모든 코드, 데이터 및 상태를 포함합니다.
        
        **쓰레드**는 프로세스 내에서 실행되는 작업의 단위입니다. 프로세스는 최소 하나의 쓰레드를 가지고 필요에 따라 여러 쓰레드를 사용할 수 있습니다. 쓰레드는 같은 프로세스 내에서 메모리와 자원을 공유하기 때문에 쓰레드간 통신이 가능하지만, 동기화 문제로 인해 데이터 일관성을 유지에 주의해야합니다.
        
        ---
        
        - **프로세스의 장점**:
            - 독립된 메모리 공간을 가지므로, 한 프로세스의 문제로 인해 다른 프로세스가 영향을 받지 않습니다.
            - 운영 체제의 보호 메커니즘을 통해 안정성과 보안성이 높습니다.
        - **프로세스의 단점**:
            - 프로세스 간의 통신(IPC: Inter-Process Communication)은 복잡하고 비용이 많이 듭니다.
            - 프로세스를 생성하거나 종료하는 비용이 높습니다.
        - **쓰레드의 장점**:
            - 같은 프로세스 내에서 메모리와 자원을 공유하므로, 쓰레드 간의 통신이 빠르고 효율적입니다.
            - 쓰레드 생성 및 관리 비용이 상대적으로 적습니다.
        - **쓰레드의 단점**:
            - 자원을 공유하므로, 동기화 문제로 인해 데이터 일관성을 유지하는 것이 어렵습니다.
            - 하나의 쓰레드가 문제를 일으키면, 같은 프로세스 내의 다른 쓰레드에도 영향을 미칠 수 있습니다.
        - 교착상태?
    - 오경민
        
        프로세스는 운영체제로부터 자원을 할당받아 실행되는 프로그램 단위를 의미합니다. 각 프로세스는 독립적인 메모리 영역을 가지기 때문에, 다른 프로세스와 메모리를 공유하지 않습니다.
        스레드는 프로세스 내에서 실행되는 작업의 단위를 의미하는데요, 각각의 프로세스 내에서 여러 개가 동시에 실행될 수 있고, 각각 스레드는 프로세스의 메모리 공간을 공유하여 사용합니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        1. Deadlock (교착 상태)에 대해 설명해주세요.
        2. 프로세스 동기화에 대해 설명해주세요.
        3. 멀티 쓰레드가 어떻게 동시에 작업을 처리할 수 있는지 설명해주세요. → 관련자료 참조
        4. 자바스크립트가 왜  싱글스레드이고, 멀티스레와 비교했을때의 이점이 무엇인지 설명해주세요. 

🔥 **피드백(1~2)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 이지혜 |  |
    | --- | --- | --- | --- |
    | 좋았던 점 | 1. 클로저는 방대한 내용이다 보니 간략하게 설명하는게 쉽지 않았을텐데, 핵심 키워드를 포함해서 간략하게 잘 설명해 주셔서 좋았습니다. 렉시컬 환경과 렉시컬 환경을 구성하고 있는 요소에 대해서도 잘 설명해 주셨고, 리액트에서 클로저 활용예시도 잘 설명해 주셔서 좋았습니다.
    
    2. 이 부분도 핵심적인 내용들만 간추려서 잘 설명해 주셨습니다.  | 1. 답변 내용이 적절하고, 말씀하시는 톤과 어조도 좋았습니다.
    2. 추가 질문에 대해서도 잘 답변해주셨고, 의도했던 답변 키워드를 포함해서 설명해주셔서 좋았습니다.
    3. 모르는 질문을 받았을 때 당황하지 않고 답변해주시는 부분이 좋았습니다. |  |
    | 개선사항 | 크게 개선사항은 없는 것 같습니다. 아주 잘하셨습니다. |  |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 이지혜 |
    | --- | --- | --- |
    | 좋았던 점 | 전체적인 톤, 속도가 아주 좋았습니다.
    1. 필요한 내용들로만 아주 이해하기 좋게 설명해주셨습니다. 추가 질문도 렉시컬 스코프의 구성을 언급하며 잘 답변해주셔서 좋았습니다.
    2. 항목별로 핵심만 나누어서 잘 설명해주셨습니다. | 1. 딥한 부분까지 잘 답변해주셔서 이 부분에 대해 잘 알고있구나 라는 생각이 들었습니다.
    2. 추가질문에 대해서도 useState가 왜 클로저인지에 대해 함께 설명해주셔서 좋았습니다.
     |
    | 개선사항 | 꼬리질문이 들어왔을 때 헷갈리는 질문의 경우 잠깐 정리하시고 답변하시면 더 좋을 것 같습니다.
    1. 클로저의 주의점으로 메모리 관리를 들어서 설명해주시면 좋을 것 같습니다.
    2. 실제 자바스크립트에서 멀티 쓰레드가 어떻게 동시에 작업들을 처리하는지 구조적으로만 간단하게 숙지하시면 더 좋을 것 같습니다. | 1. 자바스크립트는 왜 싱글스레드인지 / 멀티스레드와 비교했을 때의 이점을 간략하게 알고계시면 좋을 것 같습니다! |
- 이지혜
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |

---

3. 정렬 알고리즘을 아는대로 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        정렬 알고리즘 중 대표적인 알고리즘을 설명해보겠습니다.
        먼저 평균 시간 복잡도를 기준으로 나누어보자면, 버블 정렬, 선택 정렬, 삽입 정렬은 n² 의 시간복잡도를 가지고, 병합 정렬, 퀵 정렬, 힙 정렬은 n log n 의 평균 시간복잡도를 가집니다.
        이 중 버블 정렬, 병합 정렬, 삽입 정렬은 동일한 정렬 값을 가질 때, 원본 순서를 유지하는 안정 정렬 알고리즘이고, 선택 정렬, 퀵 정렬, 힙 정렬은 원본 순서의 유지가 보장되지 않는 불안정 정렬입니다.
        자바스크립트의 기본 정렬은 병합 정렬과 삽입 정렬이 합쳐진 팀소트를 사용합니다.
        
        ---
        
        **1. 버블 정렬(Bubble Sort)**:
        
        - **작동 원리**: 배열의 앞에서부터 인접한 두 요소를 비교하여, 필요한 경우 자리를 바꿔서 정렬하는 과정을 배열이 정렬될 때까지 반복합니다.
        - **시간 복잡도**: 최악, 평균 O(n²), 최선 O(n)
        - **특징**: 구현이 간단하지만, 성능이 좋지 않아 작은 배열에만 사용됩니다.
        
        **2. 선택 정렬(Selection Sort)**:
        
        - **작동 원리**: 배열에서 가장 작은 요소를 찾아 맨 앞의 요소와 교환하는 방식으로 정렬합니다. 이를 반복하여 배열을 정렬합니다.
        - **시간 복잡도**: O(n²)
        - **특징**: 메모리 사용량이 적고, 이해하기 쉬우나 성능이 좋지 않습니다.
        
        **3. 삽입 정렬(Insertion Sort)**:
        
        - **작동 원리**: 배열의 각 요소를 순차적으로 확인하여, 해당 요소를 이미 정렬된 부분의 적절한 위치에 삽입합니다.
        - **시간 복잡도**: 최악, 평균 O(n²), 최선 O(n)
        - **특징**: 작은 배열이나 거의 정렬된 배열에 적합합니다.
        
        **4. 병합 정렬(Merge Sort)**:
        
        - **작동 원리**: 배열을 반으로 나누어 정렬한 후, 다시 합치면서 정렬합니다.
        - **시간 복잡도**: O(n log n)
        - **특징**: 안정 정렬이며, 일정한 추가 메모리를 사용합니다.
        
        **5. 퀵 정렬(Quick Sort)**:
        
        - **작동 원리**: 배열에서 기준점(pivot)을 선택하여, 이를 기준으로 작은 요소와 큰 요소로 나누어 정렬하는 과정을 재귀적으로 반복합니다.
        - **시간 복잡도**: 최악 O(n²), 평균 O(n log n)
        - **특징**: 빠르고 효율적이지만, 최악의 경우 성능이 떨어질 수 있습니다. 추가 메모리 사용이 적습니다.
        
        **6. 힙 정렬(Heap Sort)**:
        
        - **작동 원리**: 배열을 힙 자료구조로 변환한 후, 힙에서 최대값을 하나씩 추출하여 정렬합니다.
        - **시간 복잡도**: O(n log n)
        - **특징**: 메모리 사용이 적고, 최악의 경우에도 일정한 성능을 보장합니다.
        
        ---
        
        **추가 질문 1**: 퀵 정렬의 최악의 경우는 언제 발생하나요?
        
        **답변**: 퀵 정렬의 최악의 경우는 피벗이 배열의 최소값이나 최대값으로 선택되는 경우에 발생합니다. 이 경우 배열이 불균형하게 분할되어 시간 복잡도가 O(n²)이 됩니다. 이를 방지하기 위해 피벗을 무작위로 선택하거나, 중앙값을 선택하는 방법을 사용할 수 있습니다.
        
        **추가 질문 2**: 병합 정렬과 퀵 정렬의 차이점은 무엇인가요?
        
        **답변**: 병합 정렬은 배열을 반으로 나누어 정렬한 후 합치는 방식으로, 안정 정렬이며 일정한 추가 메모리를 사용합니다. 반면, 퀵 정렬은 피벗을 기준으로 배열을 분할하고 정렬하며, 불안정 정렬이지만 추가 메모리 사용이 적고 평균적으로 빠릅니다.
        
        **추가 질문 3**: 힙 정렬은 어떤 상황에서 유용하게 사용될 수 있나요?
        
        **답변**: 힙 정렬은 메모리 사용이 적고 최악의 경우에도 일정한 성능(O(n log n))을 보장하기 때문에, 메모리가 제한된 환경이나 최악의 경우 성능이 중요한 상황에서 유용하게 사용될 수 있습니다.
        
    - 오경민
        
        정렬 알고리즘은 주어진 데이터들을 정해진 순서대로 나열하는 것을 의미합니다.
        
        선택정렬
        선택된 값과 나머지 데이터중에서 비교하고 알맞는 배치를 하는 알고리즘입니다. 안정성을 보장하진 않습니다.
        
        삽입 정렬
        데이터를 순회하면서 정렬이 필요한 데이터를 뽑아내고 알맞는 위치로 삽입하는 알고리즘입니다.
        
        병합정렬
        둘 이상의 부분집합으로 나누고 나누어진 각각의 부분집합들을 정렬하고 다음 부분집합들을 정렬된형태로 합치는 방식의 알고리즘
        
        버블정렬
        인접한 두 데이터를 비교하고 오름차순or내림차순으로 정렬하는 알고리즘입니다.
        
        퀵 정렬 (병합과 마찬가지로 분할정복법)
        데이터 집합 내에 기준 데이터가 되는 피벗을 정해놓고 피벗보다 큰 데이터와 작은 데이터 위치를 변경하는 정렬 알고리즘입니다.
        
        힙 정렬
        트리 기반으로 최대 힙 트리, 최소 힙 트리를 구성하고 정렬하는 알고리즘입니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        안정 정렬과 불안정 정렬에 대해서 설명해주세요
        
        자바스크립트의 기본 정렬 알고리즘은 뭘까요?
        
        정렬 알고리즘을 선택할 때 고려해야 할 부분으로 무엇이 있을까요?
        
4. 프로토타입에 대해 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        프로토타입 객체는 자바스크립트에서 객체 지향 프로그래밍을 지원하기 위해 사용됩니다.
        자바스크립트의 모든 객체는 자신의 프로토타입 객체를 가지며, **proto** 속성을 통해 접근할 수 있습니다.
        객체가 특정 속성이나 메서드를 찾을 때, 먼저 자신의 속성에서 찾고, 없으면 상위 프로토타입 객체에서 찾는데, 이 과정을 프로토타입 체인이라고 합니다.
        또한 한 객체의 프로토타입을 다른 객체로 설정하면, 프로토타입 체인을 통해 객체간 상속을 구현할 수 있습니다.
        
        ---
        
        **추가 질문 1**: 프로토타입 상속의 장점은 무엇인가요?
        
        **답변**: 프로토타입 상속을 사용하면 객체 간의 코드 재사용이 가능해집니다. 상위 객체의 메서드나 속성을 하위 객체에서 그대로 사용할 수 있어, 코드의 중복을 줄이고 유지보수성을 높일 수 있습니다.
        
        **요약**: "프로토타입 상속을 통해 코드 재사용이 가능하여 유지보수가 용이해집니다."
        
        **추가 질문 2**: ES6의 클래스 문법과 프로토타입 기반 상속의 차이점은 무엇인가요?
        
        **답변**: ES6의 클래스 문법은 프로토타입 기반 상속을 보다 간결하고 명확하게 표현하기 위해 도입되었습니다. 클래스 문법은 문법적 설탕(syntactic sugar)으로, 내부적으로는 여전히 프로토타입을 사용하여 상속을 구현합니다. 클래스 문법을 사용하면 상속과 메서드 정의가 더 직관적이고 읽기 쉽게 작성할 수 있습니다.
        
        **요약**: "ES6 클래스 문법은 프로토타입 기반 상속을 더 간결하고 명확하게 표현하며, 문법적 설탕입니다."
        
        **추가 질문 3**: 자바스크립트에서 `Object.create` 메서드의 역할은 무엇인가요?
        
        **답변**: `Object.create` 메서드는 지정된 프로토타입 객체와 속성들을 갖는 새 객체를 생성합니다. 이를 통해 명시적으로 프로토타입 체인을 설정하여 객체를 생성할 수 있습니다.
        
        ```jsx
        javascript코드 복사
        const parent = {
            greet() {
                console.log('Hello');
            }
        };
        
        const child = Object.create(parent);
        child.greet(); // "Hello"
        
        ```
        
        **요약**: "`Object.create`는 명시적으로 프로토타입 체인을 설정하여 객체를 생성합니다."
        
        **추가 질문 4**: `hasOwnProperty` 메서드는 무엇이며, 어떻게 사용되나요?
        
        **답변**: `hasOwnProperty` 메서드는 객체가 특정 속성을 자신의 속성으로 가지고 있는지 확인하는 메서드입니다. 프로토타입 체인에 속한 속성은 검사하지 않습니다.
        
        ```jsx
        javascript코드 복사
        const obj = {
            ownProp: 'I am own property'
        };
        
        console.log(obj.hasOwnProperty('ownProp')); // true
        console.log(obj.hasOwnProperty('toString')); // false
        
        ```
        
        **요약**: "`hasOwnProperty`는 객체의 자체 속성을 확인하는 메서드로, 프로토타입 체인의 속성은 검사하지 않습니다."
        
    - 오경민
        
        객체의 상위 객체 역할을 하는 객체로서, 하위 객체에 공유 프로퍼티를 제공해 하위 객체가 상위 객체의 프로퍼티를 자유롭게 사용할 수 있도록 한다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        hasOwnPerperty 메서드의 기능을 설명해주세요
        
        객체지향 프로그래밍은 무엇을 의미하나요?
        
        객체지향 프로그래밍의 특징에 대해 아는만큼 설명해주세요.
        
5. 브라우저 렌더링 과정에 대해 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        브라우저 렌더링 과정은 HTML, CSS, 자바스크립트와 같은 웹 콘텐츠를 사용자가 보는 화면으로 변환하는 과정입니다.
        먼저 브라우저는 HTML,CSS 문서를 파싱하여 DOM 트리와 CSSOM 트리를 생성합니다.
        두번째로는 DOM과 CSSOM을 결합하여 화면에 실제로 표시될 노드들로 구성된 렌더 트리를 생성합니다.
        레이아웃 단계에서는 렌더 트리를 기반으로 각 노드의 크기와 위치를 계산하여 뷰포트내에 배치합니다.
        페인팅 단계에서는 계산된 레이아웃 정보를 바탕으로 색상, 그림자, 이미지 등 스타일 정보로 픽셀을 채워 화면에 그립니다.
        마지막으로 컴포지팅 단계에서 여러 레이어로 나눠진 콘텐츠를 합성하여 최종적으로 화면에 렌더링합니다.
        
        ---
        
        DOM은 HTML 요소와 그 속성들을 트리 구조로 표현한 객체 모델입니다.
        CSSOM은 CSS 스타일 규칙을 트리 구조로 표현한 객체 모델입니다.
        렌더 트리는 화면에 실제로 표시될 노드들로 구성됩니다. display: none과 같은 스타일을 가진 요소는 렌더 트리에 포함되지 않습니다.
        레이아웃 단계에서는 뷰포트(viewport) 내에서 요소들이 어떻게 배치될지 결정됩니다.
        
        **추가 질문 1**: 리플로우와 리페인트의 차이점은 무엇인가요?
        
        **답변**: 리플로우(Reflow)는 레이아웃 단계로, DOM의 구조나 스타일이 변경되어 요소의 크기나 위치를 재계산해야 할 때 발생합니다. 리페인트(Repaint)는 레이아웃은 변경되지 않지만, 요소의 스타일(색상, 배경 등)이 변경되어 다시 그려야 할 때 발생합니다. 리플로우는 리페인트를 동반하지만, 리페인트는 리플로우를 동반하지 않습니다.
        
        **요약**: "리플로우는 레이아웃을 재계산하고, 리페인트는 스타일 변경으로 인한 화면 재그리기입니다."
        
        **추가 질문 2**: 자바스크립트는 렌더링 과정에 어떤 영향을 미치나요?
        
        **답변**: 자바스크립트는 DOM과 CSSOM을 조작할 수 있기 때문에 렌더링 과정에 큰 영향을 미칩니다. 특히, 자바스크립트는 DOM을 수정하여 리플로우와 리페인트를 유발할 수 있습니다. 성능 최적화를 위해 비동기적으로 스크립트를 로드하거나, `requestAnimationFrame`을 사용하여 렌더링 타이밍을 조절할 수 있습니다.
        
        **요약**: "자바스크립트는 DOM과 CSSOM을 조작하여 리플로우와 리페인트를 유발할 수 있습니다."
        
        **추가 질문 3**: 브라우저의 페인팅 성능을 최적화하려면 어떻게 해야 하나요?
        
        **답변**: 브라우저의 페인팅 성능을 최적화하기 위해 다음과 같은 방법을 사용할 수 있습니다:
        
        - 애니메이션은 GPU가 가속할 수 있는 CSS 속성(transform, opacity 등)을 사용합니다.
        - 리플로우를 최소화하기 위해 DOM 조작을 최소화하고, 한 번에 모아서 수행합니다.
        - `will-change` 속성을 사용하여 특정 요소가 변경될 것을 브라우저에 미리 알려 최적화를 유도합니다.
        - 복잡한 애니메이션이나 렌더링 작업은 별도의 레이어에서 처리하여 성능을 최적화합니다.
        
        **요약**: "CSS 속성 사용, DOM 조작 최소화, `will-change` 사용, 레이어 분할을 통해 페인팅 성능을 최적화할 수 있습니다."
        
        **추가 질문 4**: CSSOM과 렌더 트리의 차이점은 무엇인가요?
        
        **답변**: CSSOM은 CSS 스타일 규칙을 트리 구조로 표현한 객체 모델로, 모든 스타일 규칙을 포함합니다. 반면, 렌더 트리는 DOM과 CSSOM을 결합하여 화면에 실제로 표시될 노드들로 구성된 트리입니다. 렌더 트리는 `display: none`과 같은 스타일을 가진 요소를 포함하지 않으며, 실제 렌더링에 필요한 요소들만 포함합니다.
        
        **요약**: "CSSOM은 모든 스타일 규칙을 포함하고, 렌더 트리는 실제로 렌더링될 요소들만 포함합니다."
        
    - 오경민
        
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        리플로우와 리페인트에 대해 설명해주세요
        

🔥 **피드백(3~5)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 이지혜 |  |
    | --- | --- | --- | --- |
    | 좋았던 점 | 3. 시간복잡도를 기준으로 알고리즘 설명해 주셔서 아주 좋았습니다.
    꼬리질문 정렬알고리즘을 선택할 때 고려해야 할 사항들에 대해서 잘 설명해 주셔서 좋았습니다.
    
    4. 프로토타입 → 프로토타입 체인 순서로 잘 설명해 주셔서 좋았습니다.
    
    5. 핵심 키워드를 포함해서 브라우저 렌더링 과정에 대해 잘 설명해 주셨고, 꼬리질문도 잘 답변해 주셔서 좋았습니다. | 시간복잡도와 안정/불안정 기준에 따라 정렬을 설명을 해주신게 좋았습니다.
    핵심 내용만 요약해서 잘 대답해주신 것 같습니다.
    추가 질문에 대해서도 잘 대답해주셔서 이 부분에 대해서 잘 알고 있는 것 같다는 인상을 받았습니다. |  |
    | 개선사항 | 4. 객체지향 프로그래밍과 객체지향 프로그래밍의 특징에 대해서는 간단하게 알고 계시면 더 좋을 것 같습니다. |  |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 이지혜 |
    | --- | --- | --- |
    | 좋았던 점 | 3. 알고있는 내용을 자세히 설명한 부분이 좋았습니다.
    4. 간단한 컨셉 위주의 설명으로 간략화하셔서 좋았습니다.
    5. 전체적인 과정 압축과 꼬리질문 답변 내용도 좋았습니다. | 이론적 지식도 알고 있고, 그에 대한 실제 경험을 묻는 질문에도 적절하게 설명해주신 것 같습니다.  |
    | 개선사항 | 3. 질문 자체가 방대해서 특정 분류 기준을 정하고 거기에 맞춘 답변도 따로 준비하시면 좋을 것 같습니다. | 경험에 대한 추가 질문의 답은 조금 요약해서 설명해주셔도 좋을 것 같습니다! |
- 이지혜
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |

---

6. **React 에서 성능 최적화를 위한 기능을 설명해주세요**
    
    ✅ **답변**
    
    - 방혜찬
        
        React의 성능 최적화 중 대표적인 기능은 3가지가 있습니다.
        첫번째로 `React.memo` 를 통한 컴포넌트 메모이제이션으로 컴포넌트에 전달된 props가 변경되지 않으면 해당 컴포넌트를 리렌더링하지 않도록 합니다.
        두번째는 `useCallback`을 통한 함수 메모이제이션을 통해 의존성 배열에 설정한 변수들이 변하지 않으면 리렌더링 시에도 함수의 재선언을 방지할 수 있습니다.
        마지막으로 `useMemo`를 통한 값 메모이제이션이 있습니다. 복잡한 구조의 데이터 가공 등 성능에 영향을 미치는 복잡한 계산이 있을 때, 리렌더링 시에도 의존성 배열에 설정한 변수들이 변하지 않으면 리렌더링 시에도 계산을 실행하지 않습니다.
        
        ---
        
        **추가 질문 1**: `React.Memo`를 사용할 때, 주의해야 할 점이 있나요?
        
        **답변**: 컴포넌트의 props 에 상태 정보가 아닌 함수가 전달될 때, `useCallback` 을 사용해서 함수를 선언하지 않으면 실제 함수의 코드가 변하지 않아도 참조값이 변하기 때문에 `react.Memo` 를 사용하더라도 리렌더링이 발생하게 됩니다.
        
        **추가 질문 2**: `React.memo`와 `PureComponent`의 차이점은 무엇인가요?
        
        **답변**: `React.memo`는 함수형 컴포넌트에 적용하여 props가 변경되지 않으면 재렌더링을 방지하는 반면, `PureComponent`는 클래스형 컴포넌트에 적용하여 `shouldComponentUpdate` 메서드를 자동으로 구현하여 props와 state의 얕은 비교를 수행합니다.
        
        **추가 질문 3**: `useCallback`과 `useMemo`의 차이점은 무엇인가요?
        
        **답변**: `useCallback`은 함수의 메모이제이션을 위해 사용되며, 함수의 동일성을 유지하여 불필요한 렌더링을 방지합니다. `useMemo`는 값의 메모이제이션을 위해 사용되며, 복잡한 계산 결과를 기억하여 재계산을 피합니다.
        
        **추가 질문 4**: `useMemo`를 사용시 주의할 점이 있나요?
        
        - **최적화하려는 계산의 비용이 크지 않은 경우**useMemo를 사용함으로 발생하는 오버헤드가 더 클 수도 있다.
        - **의존성 배열이 너무 자주 변경되는 경우** useMemo는 항상 재계산되어, 성능적인 이점을 보기 어렵다.
        - **메모이제이션이 필요한지 확실하지 않은 경우** 일단 useMemo 없이 코드를 작성한 다음, 문제가 발생하면 점진적으로 최적화를 하는 것이 좋다.
        - **메모하고 있는 값이 컴포넌트로 전달되지 않은 경우** JSX에서만 사용되고 컴포넌트 트리에 더 깊이 전달되지 않으면, 대부분의 경우 최적화를 피할 수 있다.
    - 오경민
        
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        3가지 외에도 추가적인 최적화 기능을 알고 계신가요?
        
        React.memo 를 사용할 때 주의할 점을 알고 계신가요?
        
        useMemo 사용 시 주의할 점을 알고 계신가요?
        
7. **자바스크립트의 this 에 대해서 설명해주세요**
    
    ✅ **답변**
    
    - 방혜찬
        
        `this`는 자바스크립트에서 함수가 호출될 때 매개변수 외에도 기본적으로 전달되는 키워드로, 해당 함수가 실행되는 컨텍스트을 나타냅니다.
        `this`의 값은 함수가 호출되는 방식에 따라 크게 3가지로 나뉩니다.
        **global scope 에서 함수를 호출할 때,** `this`는 전역 객체로서 브라우저 환경에서는 window, Node.js 환경에서는 global 객체가 됩니다.
        **객체의 메서드를 호출할 때**, `this`는 메서드를 호출한 객체를 가리킵니다.
        **생성자 함수를 호출할 때**, `this`는 새로 생성된 객체를 가리킵니다.
        추가적으로 `call`, `apply`, `bind` 메서드를 사용하여 `this`를 직접 설정할 수도 있습니다.
        
        ---
        
        화살표 함수는 `this`를 자신이 정의된 렉시컬 스코프에서 상속받습니다. 
        화살표 함수는 자신이 정의된 렉시컬 문맥에서 `this`를 상속받으며, 일반 함수는 호출 시점에서 `this`가 결정됩니다. 
        `apply`는 함수의 인수를 배열로 받는 반면, `call`은 인수를 개별적으로 받습니다.
        
    - 오경민
        
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        useStrict 를 사용한 경우 어떤 차이점이 있나요?
        
        바인딩 규칙의 우선순위를 알고 계시나요?
        
        명시적 바인딩 규칙에 대해서 설명해주세요
        
        전역 스코프에서 this 는 무엇을 가리키나요?
        
    
    🔥 **피드백(6~7)**
    
    - 방혜찬
        
        
        | 면접관 | 오경민 | 이지혜 |  |
        | --- | --- | --- | --- |
        | 좋았던 점 | 핵심적인 부분만 잘 간추려서 대답해 주셔서 좋았습니다. 경험에 대해서도 잘 설명해 주셨고 꼬리질문에 대해서도 답변 잘 해주셨습니다. | 전체적인 내용과 분량 모두 좋았습니다.
        꼬리질문으로 드린 경험에 대해서도 적절한 분량으로 잘 설명해주셔서 좋았습니다. |  |
        | 개선사항 | 최적화 내용을 몇가지 추가적인 내용을 대답해 주셨으면 더 좋았을 것 같습니다.! | 최적화 관련해서 3가지가 있다~, 라고 하셨는데 그 외에도 있기 때문에 대표적인 몇가지 정도로 말씀해주셔도 좋을 것 같고, 그 외의 최적화 기법에 대해서도 몇가지 말씀해주시면 좋을 것 같습니다! |  |
    - 오경민
        
        
        | 면접관 | 방혜찬 | 이지혜 |
        | --- | --- | --- |
        | 좋았던 점 | 6. 전체적으로 간략한 설명과 중요한 기능, 추가적인 기능을 분리하여 설명한 것도 좋았습니다. | 사용 예시에 대해 핵심내용을 포함하여 적절한 분량으로 잘 설명해주셨습니다. |
        | 개선사항 | 7. this 자체에 대한 설명 부분이 조금 길어진 감이 있어 요약이 필요할 것 같습니다. | this에 대한 설명은 조금 길었던 것 같아서 조금 더 요약해줘도 좋을 것 같습니다! |

---

8. **TDD 의 개념과 장점을 설명해주세요.**
    
    ✅ **답변**
    
    - 방혜찬
        
        TDD는 기능에 대한 자동화된 테스트케이스를 작성하고 해당 테스트를 통과하는 가장 간단한 코드를 작성하고, 그 다음 리팩토링하는 과정을 반복하는 개발 방식입니다.
        테스트를 작성하기 위해 해당 기능의 요구사항과 명세를 분명히 이해해야 하기 때문에 코드를 작성하기 전에 보다 요구사항에 집중할 수 있는 장점이 있습니다.
        또 테스트가 코드의 기능을 보장해주기 때문에 리팩토링 시 안정성을 확보할 수 있고, 새로운 기능을 추가할 때 새로운 기능의 작동 여부와 함께 기존의 기능들의 작동 여부도 같이 확인할 수 있습니다.
        단점은 코드량이 늘어나는 것은 사실이기 때문에 코드 퀄리티보다는 빠른 생산성이 요구되는 경우 적절하지 않을 수 있습니다.
        또 어떠한 부분을 어떻게 테스트해야할 지, 여러 테스트 프레임워크 중 어떤 것이 우리의 서비스와 맞는지 등 여러 부분들에 대한 학습 시간과 적응 시간이 필요합니다.
        마지막으로 테스트를 반드시 해봐야 하는 부분에 있어서 테스트 코드를 작성하는데 어려움이 있는 경우, 실제 코드보다 테스트를 위한 코드 구조를 작성하게 될 수 있습니다.
        
        ---
        
        **추가 질문 1**: TDD를 적용할 때 겪을 수 있는 어려움은 무엇인가요?
        
        **답변**: 초기 개발 속도가 느려질 수 있고, 테스트 케이스 작성에 익숙하지 않으면 어려울 수 있습니다. 또한, 테스트 작성에 필요한 추가 시간이 필요합니다.
        
        **추가 질문 2**: TDD를 적용할 때 어떤 도구를 사용하나요?
        
        **답변**: TDD를 적용할 때는 JUnit, NUnit, Jest, Mocha 등 다양한 테스트 프레임워크를 사용할 수 있습니다.
        
        **추가 질문 3**: TDD와 BDD의 차이점은 무엇인가요?
        
        **답변**: TDD는 기능을 개발하기 전에 테스트를 먼저 작성하는 반면, BDD(Behavior-Driven Development)는 사용자 행동에 초점을 맞춘 시나리오 기반 테스트를 작성합니다. BDD는 더 직관적이고 이해하기 쉬운 테스트 케이스 작성을 목표로 합니다.
        
    - 오경민
        
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        
9. **객체 지향 프로그래밍에 대해서 설명해주세요.**
    
    ✅ **답변**
    
    - 방혜찬
        
        프로그램을 사물이나 개념을 반영한 객체로 구성하여 설계하고 구현하는 프로그래밍 방식입니다. 객체는 상태값과 행동을 나타내는 속성과 메서드를 통해 상호작용합니다.
        객체 지향 프로그래밍은 크게 추상화, 상속, 다형성, 캡슐화라는 4가지 특징을 가집니다.
        
        ---
        
        첫번째는 추상화로, 객체를 정의할 때 공통적인 속성과 기능을 추출하는 것을 의미합니다.
        두번째는 상속으로, 기존의 클래스를 재활용하여 새로운 클래스를 작성하면 하위 클래스들이 모두 상위 클래스의 속성과 메서드를 재사용할 수 있어 코드의 반복을 최소화할 수 있습니다.
        세번째는 다형성으로 객체의 속성이나 메서드가 상황에 따라 다른 역할을 수행하는 것입니다. 대표적인 예시는 부모 클래스의 메서드를 자식 클래스에서 오버라이딩하여 각각 다른 동작을 수행하는 경우입니다. 다형성을 활용해 프로그래밍을 설계하면 역할과 구현을 구분하여 객체들 간의 직접적인 결합을 피해 보다 유연하고 변경이 용이한 프로그램 설계가 가능합니다.
        네번째는 캡슐화로 서로 연관있는 속성과 메서드들을 하나의 캡슐(capsule)로 만들어 외부로부터 내부 상태를 보호하는 것을 말합니다. 캡슐화를 하는 이유는 외부로부터 클래스에 정의된 속성과 기능들을 보호(데이터 보호)하면서, 내부의 동작을 감추고 외부에는 필요한 부분만 노출(데이터 은닉)하기 위함입니다. 대표적인 구현 방법으로 public 필드와 private 필드를 구분하고, getter 와 setter 함수를 정의하여 사용하는 방식으로 구현이 가능합니다.
        
        **추가 질문 1**: 객체 지향 프로그래밍에서 다형성의 예는 무엇인가요?
        
        **답변**: 다형성의 예로, 부모 클래스의 메서드를 자식 클래스에서 오버라이딩하여 각각 다른 동작을 수행하게 할 수 있습니다. 예를 들어, `Animal` 클래스의 `speak` 메서드를 `Dog` 클래스와 `Cat` 클래스에서 각각 다르게 구현할 수 있습니다.
        
        **요약**: "부모 클래스 메서드를 자식 클래스에서 오버라이딩하여 다르게 동작하도록 합니다."
        
        **추가 질문 2**: 캡슐화의 목적은 무엇인가요?
        
        **답변**: 캡슐화의 목적은 객체의 내부 상태를 외부로부터 보호하고, 객체 간의 상호작용을 명확하게 정의하여 코드의 유지보수성과 보안성을 높이는 것입니다.
        
        **요약**: "객체의 내부 상태를 보호하고 상호작용을 명확하게 정의하여 유지보수성과 보안성을 높입니다."
        
        **추가 질문 3**: 객체 지향 프로그래밍과 절차적 프로그래밍의 차이점은 무엇인가요?
        
        **답변**: 객체 지향 프로그래밍은 객체를 중심으로 프로그램을 설계하고 구현하며, 상태와 행동을 함께 관리합니다. 절차적 프로그래밍은 함수와 절차를 중심으로 프로그램을 구성하며, 상태와 행동을 분리하여 관리합니다.
        
        - **메서드 오버라이딩 (Method Overriding)**:
            - 부모 클래스에 정의된 메서드를 자식 클래스에서 재정의하는 것.
            - 상속 관계에서 사용.
            - 자식 클래스는 부모 클래스의 메서드를 덮어씀.
        - **메서드 오버로딩 (Method Overloading)**:
            - 같은 이름의 메서드를 여러 개 정의하고 매개변수에 따라 다른 동작을 수행하는 것.
            - 자바스크립트는 기본적으로 지원하지 않음.
            - 매개변수의 개수나 유형을 검사하여 다르게 처리하는 방식으로 흉내낼 수 있음.
    - 오경민
        
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        

🔥 **피드백(8~9)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 이지혜 |  |
    | --- | --- | --- | --- |
    | 좋았던 점 | TDD의 내용, 장점에 대해서 잘 말씀해 주셨습니다.
    
    객체지향 프로그래밍의 개념과 특징에 대해서 잘 설명해 주셨습니다. | 주요 특징에 대해 핵심 내용을 위주로 잘간추려서 설명해주셨습니다.
    말하는 중에 꼬였을때 다시 정리하고 말씀드리겠습니다. 하고 잘 설명해주신 부분이 좋았습니다. |  |
    | 개선사항 | 테스팅 도구 jest & rtl 과 cypress에 대해 좀더 설명이 있었으면 좋았을듯 합니다. |  |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 이지혜 |
    | --- | --- | --- |
    | 좋았던 점 | 8. 개념 설명 후 대표적인 특징 위주로 풀어서 설명해 준 부분이 좋았습니다.
    꼬리질문도 아주 잘 준비해주셔서 좋았습니다.
    9. 방대한 내용의 주제를 자세히 설명하는 것 보다 간단하게 요약하고 꼬리질문으로 유도하는 것이 좋았습니다. | 추가 질문에 대해 질문한 의도와 맞게 설명해주셨습니다.
    테스팅 툴의 종류와 그에 대한 내용, 사용 예시에 대해서도 잘 설명해주셨습니다.
    큰 개념에 대해서 잘 요약해서 설명해주심  |
    | 개선사항 | 8. 테스팅 라이브러리 선정 이유를 설명할 때, 해당 라이브러리의 장점 말고도 다른 라이브러리와의 차별점을 어필해주시면 더 좋을 것 같습니다.
    9. 객체 지향 프로그래밍 내용이긴 하지만 js 문법과 연관되는 부분은 보너스로 한번 기억만 해두시면 좋을 것 같습니다.(class 문법 or 클로저 등) | TEST 코드를 작성할때 조심해야할 점에 대해서 추가적으로 알고 계시면 좋을 것 같습니다! |

---

10. **실행 컨텍스트에 대해 설명해 주세요**
    
    **참고자료**
    
    https://tc39.es/ecma262/#sec-execution-contexts
    
    ✅ **답변**
    
    - 방혜찬 🔧
        
        실행 컨텍스트(execution context)는 코드가 실행되는 환경으로, 실제 콜 스택에 쌓이는 단위입니다. 
        
        ---
        
        내부적으로는 선언된 변수나 함수와 함수의 매개변수를 저장하는 변수 객체, 실행중인 코드의 스코프를 관리하는 스코프 체인, this 의 참조객체를 정의하는 this 바인딩으로 구성됩니다.
        다음으로 실행 컨텍스트의 종류는 총 3가지 입니다.
        첫번째는 전역 실행 컨텍스트(Global Execution Context) 로 스크립트가 처음 실행될 때 생성되고 어플리케이션이 종료될 때 까지 유지되고, 브라우저에서는 전역 객체 window가 해당됩니다.
        두번째로 함수 실행 컨텍스트는 함수가 호출될 때 생성되고 호출이 끝날때까지 소멸하는 해당 함수의 실행 환경이 정의됩니다.
        마지막으로는 eval 함수가 실행될 때 생성되는 평가 실행 컨텍스트가 있습니다.
        
        ---
        
        scope chain = execution context chain
        lexical environment = lexical scope
        
        - Environment record: 변수와 값
        - Outer environment record: 외부 변수, 함수
        
        ### 추가 질문 및 답변:
        
        **추가 질문 1**: 클로저와 실행 컨텍스트의 관계는 무엇인가요?
        
        **답변**: 클로저는 외부 함수의 변수에 접근할 수 있는 내부 함수로, 실행 컨텍스트가 소멸된 후에도 변수 객체를 참조할 수 있습니다. 이는 클로저가 생성될 때의 스코프 체인을 통해 가능합니다.
        
        **요약**: "클로저는 실행 컨텍스트가 소멸된 후에도 외부 함수의 변수에 접근할 수 있습니다."
        
        **추가 질문 2**: 전역 실행 컨텍스트와 함수 실행 컨텍스트의 차이점은 무엇인가요?
        
        **답변**: 전역 실행 컨텍스트는 애플리케이션이 종료될 때까지 유지되며, 전역 변수와 함수를 관리합니다. 함수 실행 컨텍스트는 함수 호출 시 생성되고, 함수 내의 변수와 매개변수를 관리하며, 함수 실행이 끝나면 소멸됩니다.
        
        **요약**: "전역 실행 컨텍스트는 지속적으로 유지되며, 함수 실행 컨텍스트는 함수 호출 시 생성되고 소멸됩니다."
        
        **추가 질문 3**: 실행 컨텍스트와 호이스팅의 관계는 무엇인가요?
        
        **답변**: 실행 컨텍스트의 생성 단계에서 변수와 함수 선언이 처리되어 코드가 실제로 실행되기 전에 메모리에 할당됩니다. 이를 통해 변수와 함수 선언이 코드의 어느 위치에 있든지 상관없이 접근할 수 있게 됩니다.
        
        **요약**: "실행 컨텍스트 생성 단계에서 변수와 함수가 호이스팅되어 코드 실행 전에 메모리에 할당됩니다."
        
    - 오경민
        
        실행할 코드에 제공할 환경 정보들을 모아놓은 객체입니다.
        실행 컨텍스트는 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 객체를 구성하고,
        이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장합니다
        
    - 이지혜
        
        ### 실행 컨텍스트란?
        
        **실행 컨텍스트**는 마치 **"생각의 상자"** 같아요. 우리가 어떤 일을 할 때 그 일을 어떻게 할지 생각하면서 순서를 정하잖아요? 실행 컨텍스트도 비슷하게, 컴퓨터가 자바스크립트라는 언어로 프로그램을 실행할 때 **"지금 무엇을 해야 하고, 어떻게 해야 하는지"**를 기억해두는 상자예요.
        
        ### 어떻게 작동하나요?
        
        1. **새로운 일을 시작할 때**:
            - 자바스크립트가 새로운 코드를 실행하려고 하면, **새로운 상자**(실행 컨텍스트)가 만들어져요. 이 상자에는 **무엇을 해야 할지, 어떤 변수를 사용할지** 등이 들어있어요.
        2. **상자가 쌓이는 것**:
            - 만약 또 다른 코드를 실행해야 한다면, 새로운 상자가 만들어지고, 기존의 상자 위에 쌓여요. 그래서 먼저 시작한 일부터 차례대로 처리하게 되는 거죠. 이걸 **"스택"**이라고 해요.
        3. **일이 끝나면**:
            - 하나의 일이 끝나면 그 상자는 스택에서 사라지고, 아래에 쌓여있던 상자로 돌아가서 계속 일을 해요.
        
        ### 예를 들어볼게요:
        
        - **엄마가 저녁을 준비해요.**
            - 이게 하나의 실행 컨텍스트(생각의 상자)예요.
            - 저녁을 준비하면서 **채소를 씻고, 자르고, 요리하는 순서**를 기억해두죠.
        - **갑자기 전화가 와요.**
            - 엄마는 전화를 받기 위해 저녁 준비를 잠시 멈추고, **전화 받기**라는 새로운 상자를 만들어서 그 일을 처리해요.
        - **전화가 끝나면**, 다시 저녁 준비를 이어가면서 원래 상자로 돌아가죠.
        
        이렇게 자바스크립트도 여러 가지 일을 할 때마다 각각의 실행 컨텍스트를 만들어서, 무엇을 해야 하는지 기억하고 차례대로 일을 처리해요.
        
        이게 바로 **실행 컨텍스트**예요!
        
    - **❓ 꼬리질문**
        
        실행 컨텍스트에서 클로저와 관련된 부분을 설명해주세요
        
        실행 컨텍스트와 호이스팅의 관계는 무엇인가요?
        
11. **제어 컴포넌트와 비제어 컴포넌트의 차이에 대해 설명해주세요**
    
    ✅ **답변**
    
    - 방혜찬
        
        두 가지 모두 React에서 폼 입력 요소를 관리하는 방법입니다.
        제어 컴포넌트(Control Component)는 input 값을 컴포넌트의 상태(state)로 관리하고, 값의 변화는 이벤트 핸들러 함수에서 상태의 세터함수를 사용하는 방식으로 구현합니다.
        따라서 입력 값의 검증과 변환을 실시간으로 처리할 수 있고, 폼 데이터의 상태관리를 중앙 집중형으로 하기때문에 디버깅이 용이합니다. 다만 입력 요소들이 많아질수록 많은 상태 변화가 일어나기 때문에, 성능에 영향을 줄 수 있습니다.
        비제어 컴포넌트(Uncontrolled Component)는 input 값에 접근하기 위해 ref 속성을 사용합니다. input 값을 상태가 아닌 DOM 에서 직접 관리하고, React 의 컴포넌트와 동기화되지 않기 때문에 입력 값의 실시간 검증과 변환이 어렵습니다.
        대신 input 요소의 관리 코드가 간단해지고, 초기 값 설정이 용이하며, 상태 업데이트를 사용하지 않아 성능에 영향을 덜 미칩니다.
        
        ---
        
        **추가 질문 1**: 제어 컴포넌트에서 상태를 업데이트할 때 주의해야 할 점은 무엇인가요?
        
        **답변**: 상태 업데이트가 비동기적으로 처리될 수 있으므로, 상태를 변경할 때 현재 상태를 참조하여 업데이트하는 것이 중요합니다. 예를 들어, 함수형 업데이트를 사용하여 이전 상태에 기반한 업데이트를 수행합니다.
        
        **요약**: "제어 컴포넌트에서 상태 업데이트 시 현재 상태를 참조하여 업데이트하는 것이 중요합니다."
        
        **추가 질문 2**: 제어 컴포넌트와 비제어 컴포넌트를 혼합하여 사용할 수 있나요?
        
        **답변**: 네, 상황에 따라 제어 컴포넌트와 비제어 컴포넌트를 혼합하여 사용할 수 있습니다. 예를 들어, 초기 값 설정 시 비제어 컴포넌트를 사용하고, 이후 입력 값을 제어 컴포넌트로 관리할 수 있습니다.
        
        **요약**: "제어 컴포넌트와 비제어 컴포넌트를 혼합하여 사용할 수 있습니다."
        
        **추가 질문 3**: 제어 컴포넌트가 적합한 경우와 비제어 컴포넌트가 적합한 경우는 언제인가요?
        
        **답변**: 제어 컴포넌트는 폼 데이터의 상태를 중앙에서 관리하고 검증해야 할 때 적합하며, 비제어 컴포넌트는 단순한 폼 입력이나 초기 값 설정이 필요한 경우에 적합합니다.
        
        **요약**: "제어 컴포넌트는 중앙 관리와 검증이 필요할 때, 비제어 컴포넌트는 단순 입력이나 초기 값 설정에 적합합니다."
        
    - 오경민
        
        useState를 사용해서 DOM 요소의 값을 관리하면 제어 컴포넌트이다. 
        
        useRef를 사용해서 값을 관리하는 방식을 비제어 컴포넌트라고 한다.
        비제어 컴포넌트는 값이 실시간으로 동기화 되지 않는다. 비제어 컴포넌트는 사용자가 직접 트리거 하기 전까지는 리렌더링을 발생시키지도 않고 값을 동기화 시키지도 않는다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        비제어 컴포넌트는 input 태그의 어떤 속성을 사용하나요?
        
        제어 컴포넌트의 장단점을 설명해주세요.
        
        제어, 비제어 컴포넌트를 동시에 사용 가능할까요?
        

🔥 **피드백(10~11)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 이지혜 |  |
    | --- | --- | --- | --- |
    | 좋았던 점 | 10. 질문에 대한 답변을 간추려서 잘 말씀해 주셨습니다.
    
    11. 제어, 비제어 컴포넌트도 비교설명 잘 해주셨습니다. | 역할, 구성요소와 종류, 예시 / 중요한 키워드, 장단점을 포함하여 간단명료하게 잘 설명해주셔서 좋았습니다. |  |
    | 개선사항 |  | 어디까지 바로 답을하고 어떤 부분을 꼬리질문으로 유도해야할지는 저도 고민해봐야할 부분일 것 같습니다.🤔 |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 이지혜 |
    | --- | --- | --- |
    | 좋았던 점 | 10. 방대한 내용을 개념적으로 압축하셔서 간단하게 잘 설명하셨습니다.
    11.  두가지의 사용 방식을 잘 비교해주셨습니다. | 문제를 이해하지 못했을때 어떤 질문인지 의도를 다시 확인하고 대답을 한 부분이 좋았던 것 같습니다. |
    | 개선사항 | 11. 두 방식의 장단점을 간단하게만 비교하는 내용을 추가해주시면 더 좋을 것 같습니다. | useRef와 useState를 각각 어디서 사용하는지 예시도 알고계시면 졸을 것 같습니다! |

---

12. **ES6 문법에 대해 아는 만큼 설명해 주세요**
    
    ✅ **답변**
    
    - 방혜찬
        
        ES6 는 2015년에 업데이트된 ECMAScript 버전인데요, 주요 기능을 위주로 설명해보겠습니다.
        첫번째로 변수 선언을 위한 let과 const 키워드가 추가됐습니다.
        **(블록 스코프, 호이스팅, 재선언 및 재할당)**
        두번째로 화살표 함수가 추가되어 더 간결한 함수 선언이 가능해졌습니다.
        **(this에 선언될 시점에서의 상위 스코프의 this 가 바인딩되고 이로인해 객체의 메서드에 쓰면 의미가 없어진다. 생성자는 사용 불가)**
        세번째로 비동기 작업을 처리하기 위한 프로미스 객체가 추가됐습니다.
        **(함수의 완료/실패 후 실행할 로직을 파라미터에 함수로 넣어주는 이른바 콜백 지옥을 개선할 수 있다.)**
        그 외에도 백틱(`)을 활용한 템플릿 리터럴, 배열이나 객체의 값을 펼쳐서 사용하는 스프레드 문법, 배열이나 객체의 값을 추출해서 변수로 할당하는 구조분해할당, 프로토타입 기반의 프로그래밍을 간편화한 클래스 문법, require 와 module.export 대신 import 와 export 를 사용한 모듈 사용법 등이 있습니다.
        
        ECMAScript & JavaScript
        https://wormwlrm.github.io/2018/10/03/What-is-the-difference-between-javascript-and-ecmascript.html
        
    - 오경민
        
        const, let
        기존 var  키워드의 호이스팅 문제점을 개선하고자 나온 키워드입니다.
        
        화살표 함수
        간결하고 보기쉬운 문법, this
        
        import와 export
        의존성 관리의 어려움, 전역 스코프 문제 해결을 위해 나온 문법
        
        Template Literals(템플릿 리터럴)
        백틱(`)을 사용하여 문자열 내에서 변수를 사용할 수도 있습니다.
        
        구조 분해 할당 (Destructuring assignment)
        구조 분해 할당 구문은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 자바스크립트 표현 방식입니다.
        
        스프레드 연산자
        기존 배열이나 객체의 전체 또는 일부를 다른 배열이나 객체로 빠르게 복사할 수 있습니다.
        
        Class
        
        Promise
        프로미스는 자바스크립트 비동기 처리에 사용되는 객체입니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        가장 유용한 것은 무엇이었나요?
        
        스프레드 연산자의 용도를 아는 만큼 설명해주세요. → 데이터의 불변성을 활용하기 위해, 스프레드 연산자를 배열과 객체에 사용했을 때 차이, 함수의 파라미터의 사용하는 경우에 대해서 아시나요?
        
        promise 활용 경험이 있으신가요?
        
        property shortand 문법을 아시나요?
        
13. **CORS 정책이란 무엇인지 설명해주세요.**
    
    ✅ **답변**
    
    - 방혜찬
        
        CORS(Cross-Origin Resource Sharing)는 웹 브라우저의 보안 모델로에서 다른 출처의 자원에 접근할 때 발생하는 보안 메커니즘입니다.
        기본적으로 브라우저는 동일 출처 정책(Same-Origin Policy)을 따르기 때문에, 동일한 프로토콜, 호스트, 포트의 리소스에 접근할 수 있습니다.
        CORS 로 다른 출처의 리소스를 사용하기 위해서는 먼저 PUT 이나 DELETE 같은 안전하지 않은 메서드에 한해 서버에 프리플라이트 요청을 보낸 후 응답에 포함된 CORS 헤더내용을 참조해 실제 요청을 보내게 됩니다.
        
        ---
        
        ### 1. **잘못된 CORS 설정**
        
        잘못된 CORS 설정은 원래 허용되지 않은 도메인에서의 접근을 허용하여 민감한 데이터에 접근할 수 있게 합니다.
        
        - **문제**: 모든 도메인(``)에 대해 CORS를 허용하면, 신뢰할 수 없는 도메인도 접근할 수 있습니다.
        - **해결 방법**: 필요한 도메인만 허용하고, 와일드카드(``)를 피해야 합니다. 예를 들어, `Access-Control-Allow-Origin: https://trusted-domain.com`.
        
        ### 2. **Credential 포함 요청**
        
        CORS 요청에 자격 증명(쿠키, 인증 헤더 등)을 포함하면, 보안 위협이 될 수 있습니다.
        
        - **문제**: 민감한 데이터가 포함된 요청이 신뢰할 수 없는 도메인에 의해 실행될 수 있습니다.
        - **해결 방법**: `Access-Control-Allow-Credentials` 헤더를 필요에 따라 설정하고, 허용된 도메인에서만 자격 증명 포함 요청을 허용해야 합니다. 예를 들어, `Access-Control-Allow-Credentials: true`.
        
        ### 3. **Preflight 요청 무시**
        
        CORS의 Preflight 요청은 실제 요청 전에 서버가 요청을 허용하는지 확인하는 과정입니다.
        
        - **문제**: Preflight 요청을 무시하면, 잠재적으로 위험한 요청이 실행될 수 있습니다.
        - **해결 방법**: Preflight 요청(`OPTIONS` 요청)에 적절히 응답하도록 서버를 설정해야 합니다.
        
        ### 4. **복잡한 CORS 규칙**
        
        CORS 규칙이 너무 복잡하면 설정 오류가 발생할 수 있습니다.
        
        - **문제**: 복잡한 규칙은 설정 오류를 유발하여 보안 허점을 만들 수 있습니다.
        - **해결 방법**: 가능한 한 간단하고 명확하게 CORS 규칙을 설정하고, 주기적으로 검토합니다.
        
        ### 5. **정적 파일과 API에 대한 분리된 CORS 정책**
        
        정적 파일과 API 요청에 대해 동일한 CORS 정책을 적용하는 것은 위험할 수 있습니다.
        
        - **문제**: API 요청을 위한 CORS 설정이 정적 파일에도 적용되면, 불필요한 자원 접근이 허용될 수 있습니다.
        - **해결 방법**: 정적 파일과 API 요청에 대해 서로 다른 CORS 정책을 설정합니다.
        
        ---
        
        - **프리플라이트 요청(Preflight Request)**: 브라우저는 실제 요청 전에 `OPTIONS` 메서드를 사용하여 서버에 프리플라이트 요청을 보냅니다. 서버가 허용하는 HTTP 메서드와 헤더를 확인합니다.
        - **응답 헤더**:
            - `Access-Control-Allow-Origin`: 허용된 출처를 지정합니다.
            - `Access-Control-Allow-Methods`: 허용된 HTTP 메서드를 지정합니다.
            - `Access-Control-Allow-Headers`: 허용된 요청 헤더를 지정합니다.
            - `Access-Control-Allow-Credentials`: 자격 증명(쿠키, 인증 헤더 등)을 포함할 수 있는지 여부를 지정합니다.
            - Access-Control-Allow-Origin: [https://example.com](https://example.com/)
            Access-Control-Allow-Methods: GET, POST, PUT
            Access-Control-Allow-Headers: Content-Type
            Access-Control-Allow-Credentials: true
        
        **추가 질문 1**: 프리플라이트 요청이 항상 필요한가요?
        
        **답변**: 아니요, 프리플라이트 요청은 안전하지 않은 HTTP 메서드(예: PUT, DELETE) 또는 사용자 정의 헤더가 있는 경우에만 필요합니다. 단순 요청(GET, POST)에는 필요하지 않습니다.
        
        **요약**: "프리플라이트 요청은 안전하지 않은 메서드나 사용자 정의 헤더가 있는 경우에만 필요합니다."
        
        **추가 질문 2**: `Access-Control-Allow-Origin` 헤더에 와일드카드(*)를 사용하는 것은 안전한가요?
        
        **답변**: 와일드카드(*)를 사용하면 모든 출처에 대한 접근을 허용합니다. 이는 보안 취약점을 초래할 수 있으므로, 가능한 경우 특정 출처를 명시하는 것이 좋습니다.
        
        **요약**: "와일드카드(*)는 모든 출처를 허용하므로, 보안상 특정 출처를 명시하는 것이 좋습니다."
        
        **추가 질문 3**: CORS가 필요한 상황은 언제인가요?
        
        **답변**: CORS는 API 서버가 다른 출처의 웹 애플리케이션에서 데이터를 요청할 때 필요합니다. 예를 들어, 다른 도메인의 API를 호출하거나, 프론트엔드와 백엔드가 다른 도메인에 호스팅된 경우입니다.
        
        **요약**: "CORS는 다른 출처의 API 서버와 웹 애플리케이션 간의 데이터 요청 시 필요합니다."
        
        XSS(Cross-Site Scripting)는 웹 애플리케이션의 보안 취약점 중 하나로, 공격자가 악성 스크립트를 웹 페이지에 삽입하여 다른 사용자의 브라우저에서 실행되도록 하는 공격입니다. 이를 통해 공격자는 사용자의 세션을 탈취하거나, 데이터를 유출하거나, 악성 소프트웨어를 배포할 수 있습니다.
        
        CSRF(Cross-Site Request Forgery)는 웹 애플리케이션의 보안 취약점 중 하나로, 공격자가 사용자를 대신하여 원치 않는 행동을 수행하도록 하는 공격입니다. 이를 통해 공격자는 사용자의 권한을 도용하여 민감한 데이터를 유출하거나 계정 설정을 변경하는 등의 악의적인 행위를 할 수 있습니다.
        
    - 오경민
        
        서로 다른 Origin(출처) 간의 리소스 공유를 허용할지 결정하는 정책입니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        CORS 가 무엇이고, 해결한 경험이 있다면 설명해주세요.
        
        그러면 브라우저에서 사용하는 기본 정책은 뭘까요?
        
        서버의 cors 정보를 요청하는 HTTP 메서드를 아시나요?
        
        발생할 수 있는 보안 문제의 예시가 있을까요?
        
        동일 출처 정책이 필요한 이유가 무엇일까요? 
        
        Next.js 에서는 CORS를 어떻게 처리하고 있나요?
        

🔥 **피드백(12~13)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 이지혜 |  |
    | --- | --- | --- | --- |
    | 좋았던 점 | 간결하게 요약해서 답변해 주셔서 좋았습니다. 답변의 길이가 딱 적당했던 것 같습니다. | 방대한 내용이었는데 핵심 내용을 기반으로 잘 설명해주신것같고 추가질문을 유도해서 그에 대한 답도 잘 해주신것같습니다. |  |
    | 개선사항 | 피드백 내용은 크게 없지만, CORS 해결 사례를 좀 더 자세하게 준비하시면 좋을 것 같습니다. | 네트워크에 대한 지식도 너무 좋은데 우선은 프론트엔드 직무에 지원하는거니까 리액트나 next에서는 어떻게 처리하고 있는지 알고있다면 더 좋지 않을까 생각됩니다. + 경험 |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 이지혜 |
    | --- | --- | --- |
    | 좋았던 점 | 12. 본인 기준으로 중요한 내용 설명 후 나머지는 간결한 요약으로 설명해주셔서 좋았습니다. | 종류와 개념에 대해 너무 길지 않게 잘 정리해서 설명해주신 것 같습니다. |
    | 개선사항 | 12. spread 연산자나, property shortand 같은 문법들의 간단한 사용예시도 알아두시면 더 좋을 것 같습니다.
    13. CORS 와 관련된 OPTIONS 메서드의 개념 정도만 기억해두시면 좋을듯합니다. | 경험에 대해 묻는 질문에 스프레드 연산자를 답해주셨으니까 그부분에 대해 조금 더 정확하게 알고계시면 좋을 것 같습니다. |

---

14. **HOC (Higher-Order Components)에 대해 설명해주세요.**
    
    ✅ **답변**
    
    - 방혜찬
        
        HOC 는 React에서 컴포넌트를 인수로 받아서 새로운 컴포넌트를 반환하는 함수로 컴포넌트를 재사용하고 로직을 공유하는 패턴입니다.
        이러한 방식을 통해 여러 컴포넌트에 같은 로직을 하나의 함수로 재사용할 수 있고, 원본 컴포넌트와 분리된 상태로 관리할 수 있으며, 다양한 로직의 HOC들을 조합하여 기능을 확장할 수 있다는 특징이 있습니다.
        
        ```jsx
        // 예시: 인증 기능의 HOC
        function withLoading(Component) {
          return function WithLoadingComponent({ isLoading, ...props }) {
            if (isLoading) {
              return <p>Loading...</p>;
            }
            return <Component {...props} />;
          };
        }
        
        const ListWithLoading = withLoading(List);
        ```
        
        그 외에도 로깅 등의 용도도 가능
        
    - 오경민
        
        고차 컴포넌트는 React에서 컴포넌트를 재사용하기 위한 패턴입니다. HOC는 컴포넌트를 입력으로 받아서 새로운 컴포넌트를 반환하는 함수입니다. 이를 통해 공통 로직을 여러 컴포넌트에 추상화하여 코드의 재사용성을 높이고 중복을 줄일 수 있습니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        HOC 와 커스텀 훅의 차이점을 아시나요?
        
        사용해본 경험이나 예시.
        
        HOC 외에 코드의 재사용성을 증가시킬 수 있는 방법은 어떤게 있을까요
        
15. **MVVM 패턴과 Flux패턴에 대해서 설명해주세요**
    
    ✅ **답변**
    
    - 방혜찬
        
        MVVM 패턴은 Model, View, ViewModel 로 나뉩니다.
        Model 은 애플리케이션의 데이터와 비즈니스 로직을 관리합니다.
        View 는 UI 를 나타냅니다.
        ViewModel 은 View와 바인딩되어 데이터를 전달하고 변경 사항을 업데이트합니다.
        View와 ViewModel 간에 양방향으로 데이터 바인딩이 되어있습니다.
        Flux 패턴은 데이터 흐름을 단방향으로 제어하는데, 순서를 설명드리면 먼저 특정 작업이 발생하면 작업에 대한 정보를 담은 Action 객체가 Dispatcher 를 통해 Store 에 전달됩니다.
        Store 에서는 어플리케이션의 상태와 로직을 관리하기 때문에 Dispatcher 가 전달해준 작업을 보고 상태를 업데이트합니다.
        마지막으로 Store 의 상태를 기반으로 사용자 인터페이스인 View 가 업데이트됩니다.
        
    - 오경민
        
        MVVM UI 및 비즈니스 로직을 분리하여 유지보수성과 테스트 가능성을 높이는 아키텍처 패턴입니다. Model은 데이터와 비즈니스 로직을, View는 사용자 인터페이스를, ViewModel은 이 둘 사이의 중재자 역할을 합니다. 양방향 데이터 바인딩을 통해 View와 ViewModel이 자동으로 동기화됩니다.
        
        Flux 패턴은 단방향 데이터 흐름을 가지며, Actions, Dispatcher, Store, View로 구성됩니다. Actions는 이벤트를 정의하고, Dispatcher는 이를 Store에 전달하며, Store는 상태를 관리하고 View는 이를 렌더링합니다. 주로 React와 함께 사용되어 상태 관리의 예측 가능성을 높입니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        Flux 패턴은 어떤 모델을 보완하기 위해 나왔나요?
        
        flux 단방향 데이터 바인딩을 사용하는 이유?
        
        mvvm, flux 사용 경험이나 사용되는 예시 프레임워크를 아시나요? →MVVM은 Angular, Vue.js 등의 프레임워크에서 사용되며, Flux는 React에서 주로 사용됩니다.
        
        flux 패턴과 redux 의 차이점을 아시나요? → Flux는 여러 Store를 가질 수 있지만, Redux는 단일 Store와 순수 함수인 Reducer로 상태를 관리하며, 미들웨어를 통해 비동기 로직을 처리합니다. 
        
        mvc 의 controller 와 mvvm 의 viewmodel 의 차이점을 설명해주세요
        
16. **CSRF나 XSS 공격을 막는 방법은?**
    
    ✅ **답변**
    
    - 방혜찬
        
        CSRF 를 방지하기 위해 첫번째로는 CSRF 토큰을 사용하여 각 리퀘스트에 토큰 정보를 포함하고, 서버가 토큰을 검증하는 방식이 있습니다.
        두번째로는 서버가 리퀘스트 헤더의 Referer 를 확인하여 신뢰할 수 있는 출처인지 확인합니다.
        마지막으로 쿠키에 SameSite 속성을 사용해서 동일 출처에서만 쿠키가 전송되도록 합니다.
        XSS 를 방지하기 위해서는 첫번째로 사용자 입력을 검증하거나 인코딩하는 방식으로 악성 스크립트의 실행을 방지합니다.
        두번째로는 CSP 헤더로 스크립트가 실행될 수 있는 소스를 설정할 수 있습니다.
        마지막으로 쿠키에 HttpOnly 속성을 사용하면 javascript 로 쿠키에 접근할 수 없습니다.
        
        `Set-Cookie: sessionId=abc123; SameSite=Strict`
        
        CSRF는 서버 측에 보내는 요청을 대상으로 하며, XSS는 클라이언트 측 스크립트 실행을 목표로 합니다.
        
        XSS(Cross-Site Scripting)는 웹 애플리케이션의 보안 취약점 중 하나로, 공격자가 악성 스크립트를 웹 페이지에 삽입하여 다른 사용자의 브라우저에서 실행되도록 하는 공격입니다. 이를 통해 공격자는 사용자의 세션을 탈취하거나, 데이터를 유출하거나, 악성 소프트웨어를 배포할 수 있습니다.
        
        CSRF(Cross-Site Request Forgery)는 웹 애플리케이션의 보안 취약점 중 하나로, 공격자가 사용자를 대신하여 원치 않는 행동을 수행하도록 하는 공격입니다. 이를 통해 공격자는 사용자의 권한을 도용하여 민감한 데이터를 유출하거나 계정 설정을 변경하는 등의 악의적인 행위를 할 수 있습니다.
        
    - 오경민
    CSRF(Cross-Site Request Forgery) 공격을 방지하기 위해서는 CSRF 토큰을 사용하여 모든 상태 변경 요청에 대해 검증을 수행합니다. 사용자 세션에 대한 고유한 CSRF 토큰을 생성하고, 각 요청 시 이 토큰을 포함시켜 서버에서 유효성을 검사합니다. 또한, SameSite 쿠키 속성을 설정하여 크로스 사이트 요청 시 쿠키가 전송되지 않도록 합니다.
        
        
        XSS(Cross-Site Scripting) 공격을 방지하기 위해서는 모든 사용자 입력을 철저히 검증하고 인코딩합니다. 특히 HTML, JavaScript, CSS 등으로 출력되는 모든 데이터를 적절히 이스케이프 처리합니다. Content Security Policy(CSP)를 설정하여 스크립트 소스를 제한하고, HttpOnly와 Secure 속성을 쿠키에 설정하여 자바스크립트에서 쿠키 접근을 제한합니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        토큰 인증 방식을 아시나요?
        

🔥 **피드백(14~16)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 이지혜 |  |
    | --- | --- | --- | --- |
    | 좋았던 점 | 간략하게 핵심적인 내용들을 잘 간추려서 설명해 주셔서 좋았습니다. |  |  |
    | 개선사항 | Flux 패턴이 “MVC패턴의 단점을 보완하기 위해 나왔다” 정도만 알아두시면 좋을듯 합니다 ! |  |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 이지혜 |
    | --- | --- | --- |
    | 좋았던 점 | 15. 각 패턴의 설명 전에 장점도 설명해주셔서 좋았습니다. |  |
    | 개선사항 | 15. mvvm 패턴 같은 경우, 사용 예시도 알아두시면 좋을 듯 합니다. |  |

---

17. **함수형 프로그래밍이란 무엇인가요?**
    - **참고자료**
        
        https://velog.io/@teo/functional-programming-study#q-그러면-객체지향-프로그래밍과-함수형-프로그래밍의-차이가-뭔가요
        
    
    ✅ **답변**
    
    - 방혜찬
        
        함수형 프로그래밍은 함수들의 조립을 통해 프로그램을 구성하는 프로그래밍 방식입니다.
        중요한 개념으로는 먼저 함수 내부에서 외부의 상태를 변경하지 않으며, 같은 입력에는 같은 출력을 반환하는 순수 함수가 있습니다.
        다음은 상태 데이터는 변경하지 않고, 변경이 필요할 때 새로운 객체를 생성하는 불변성이 있습니다.
        그 외에도 고차 함수나 함수 조합등의 개념이 있습니다.
        함수형 프로그래밍은 순수함수들을 변수값이나 함수의 인자, 반환값으로도 사용하며(1급함수 개념), 함수들을 조립하여 단순한 파이프라인을 구축함으로서 함수의 출력을 예측하기 쉬워서 테스트 작성이 쉽고, 상태와 함수가 분리되어 코드의 가독성이 좋습니다.
        
        ---
        
        **추가 질문 1**: 순수 함수의 장점은 무엇인가요?
        
        **답변**: 순수 함수는 예측 가능성과 테스트 용이성을 제공합니다. 외부 상태를 변경하지 않기 때문에 디버깅이 쉽고, 코드의 유지보수성을 높입니다.
        
        **요약**: "순수 함수는 예측 가능성과 테스트 용이성을 제공하며, 외부 상태를 변경하지 않아 디버깅이 쉽습니다."
        
        **추가 질문 2**: 함수형 프로그래밍의 단점은 무엇인가요?
        
        **답변**: 함수형 프로그래밍은 복잡한 상태 관리가 필요할 때 코드가 복잡해질 수 있으며, 가변 상태가 필요할 때 성능 문제가 발생할 수 있습니다.
        
        **요약**: "함수형 프로그래밍은 복잡한 상태 관리 시 코드가 복잡해지고, 가변 상태가 필요할 때 성능 문제가 발생할 수 있습니다."
        
        **추가 질문 3**: 고차 함수의 예를 하나 더 들어보세요.
        
        **답변**: `map`, `filter`, `reduce` 함수는 고차 함수의 예입니다. `map` 함수는 배열의 각 요소에 함수를 적용하여 새로운 배열을 반환합니다.
        
        ```jsx
        javascript코드 복사
        const arr = [1, 2, 3];
        const doubled = arr.map(x => x * 2); // [2, 4, 6]
        
        ```
        
        **요약**: "고차 함수의 예로 `map`, `filter`, `reduce`가 있으며, `map` 함수는 배열의 각 요소에 함수를 적용하여 새로운 배열을 반환합니다."
        
        ---
        
        **함수는 번들을 크기를 줄이기 위해서는 사용하지 않는 코드들은 아예 포함을 시키지 않는 `트리쉐이킹`이라는 기법이 가능합니다**. 반면 클래스로 작성된 코드의 경우 메소드별로 트리쉐이킹을 할 수가 없고 객체단위로 진행이 되기 때문에 덩치가 큰 객체의 일부분만 사용을 하더라도 모두 번들에 포함이 됩니다.
        
        정리하면, 자바스크립트는 이러한 언어의 구조상 객체 메소드나 필드명은 minify를 할 수 없고 트리쉐이킹을 할 수 없기 때문에 함수로 작성하는 것에 비해 번들크기를 줄이는데 있어 불리한 구조입니다.
        
        객체지향과의 차이?
        **객체지향은 서로 관심이 있는 것끼리 모아서 관리를 하자는 입장입니다.** 문제가 발생했을 때 관심사가 같은 것끼리 묶어서 객체로 관리하게 되면 문제의 범위를 각 객체로 좁힐 수 있고, 동일한 관심사가 모인 객체를 작은 프로그램으로 취급하여 조립하고 서로 소통할 수 있도록 하자는 관점입니다.
        
        **함수형은 상태를 변화하는 것과 그렇지 않은 것들을 분리해서 관리하자는 관점입니다.** 결국 상태관리가 어려운 이유는 상태가 변화하기 때문인데 상태와 무관한 함수들을 만들면 문제가 발생하지 않거나 검증된 함수가 만들어지고 이를 조립한 함수 역시 문제가 없을 것이기에 문제가 발생할 수 있는 범위를 부수효과에 한정할 수 있도록 하자는 것입니다.
        
        **함수형 프로그래밍은 객체지향에 비해 다음과 같은 이점을 가집니다.**
        순수 함수를 사용하기 때문에 코드가 단순해집니다. 상태를 저장하는 객체가 없기 때문에, 코드를 이해하기가 쉽습니다.
        순수 함수를 사용하기 때문에 테스트가 쉬워집니다. 함수의 출력을 예측할 수 있기 때문에, 테스트 작성이 간단해집니다.
        순수 함수를 사용하기 때문에 코드가 부작용이 없어집니다. 순수 함수는 외부 상태에 의존하지 않기 때문에, 부작용을 일으키지 않습니다.
        **객체지향은 함수형 프로그래밍에 비해 다음과 같은 이점을 가집니다.**
        완성된 객체는 관심사가 같은 것으로 묶여있기 때문에 이해하기 쉽고 훨씬 더 사용하기 쉽습니다. 일례로 IDE에서 객체에 .만 찍어봐도 무슨 일을 할 수 있고 무슨 값이 있는지 알 수 있는 반면에 함수형 프로그래밍은 각 함수들을 다 알고 있어야 하며 함수간 관련도를 인자만 가지고 파악하기가 쉽지 않습니다.
        캡슐화로 인해서 외부에서 몰라도 될 코드를 숨길 수 있도록 하여 더 간결한 형태의 코드를 만들어내기에 용이합니다. (반대로 테스트와 커스텀에 불리하다는 말이기도 합니다.)
        객체지향 프로그래밍은 일반적으로 더 익숙한 프로그래밍 방식이며 관심사를 분리하기 쉬워서 코드의 가독성과 유지보수성이 높은 프로그래밍을 가능 하게 합니다.
        
        자바스크립트는 함수형 프로그래밍 패러다임의 일부와 객체지향 패러다임의 일부를 동시에 제공을 하고 있는 언어입니다.
        
        함수형 코딩을 설명하기 위한 자리이다보니 함수형 프로그래밍의 장점을 어필하고 있지만 함수형 프로그래밍이 객체지향보다 더 나은 개념은 아니라는 것이며 얼마든지 상호보완될 수 있는 개념입니다.
        
    - 오경민
        
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        고차함수? 예시?
        
        객체지향과의 차이점
        
        순수 함수와 비순수 함수의 차이는 무엇인가요?
        
18. **크로스 브라우징에 대해 설명해 주세요**
    
    ✅ **답변**
    
    - 방혜찬
        
        크로스 브라우징은 웹 애플리케이션이 다양한 웹 브라우저에서 일관된 동작과 화면을 제공하는 것을 말합니다.
        각각의 웹 브라우저는 렌더링 엔진과 자바스크립트 엔진의 차이로 인해 동일한 기능이 다른 방식으로 작동할 수 있습니다.
         W3C 표준을 준수하여 브라우저 호환성을 고려한 코드를 작성하고, 최신 기능을 지원하지 않는 브라우저에서 폴리필을 사용하거나, 기본 CSS 를 리셋하는 작업 등이 크로스 브라우징의 예시입니다.
        
        ---
        
        **추가 질문 1**: 폴리필이란 무엇인가요?
        
        **답변**: 폴리필은 최신 웹 표준 기능을 지원하지 않는 브라우저에서도 해당 기능을 사용할 수 있도록 하는 JavaScript 코드입니다.
        
        **요약**: "폴리필은 최신 웹 표준 기능을 지원하지 않는 브라우저에서도 해당 기능을 사용할 수 있도록 하는 JavaScript 코드입니다."
        
        **추가 질문 2**: 크로스 브라우징을 위해 사용할 수 있는 도구는 무엇인가요?
        
        **답변**: 크로스 브라우징을 위해 BrowserStack, CrossBrowserTesting, Sauce Labs 등의 도구를 사용하여 다양한 브라우저에서 웹 애플리케이션을 테스트할 수 있습니다.
        
        **요약**: "크로스 브라우징을 위해 BrowserStack, CrossBrowserTesting, Sauce Labs 등의 도구를 사용하여 다양한 브라우저에서 웹 애플리케이션을 테스트할 수 있습니다."
        
        **추가 질문 3**: CSS 리셋과 CSS 노말라이즈의 차이점은 무엇인가요?
        
        **답변**: CSS 리셋은 브라우저의 기본 스타일을 모두 제거하여 일관된 스타일을 만드는 반면, CSS 노말라이즈는 브라우저의 기본 스타일을 유지하면서도 일관성을 부여합니다.
        
        **요약**: "CSS 리셋은 브라우저의 기본 스타일을 제거하고, CSS 노말라이즈는 기본 스타일을 유지하면서 일관성을 부여합니다."
        
    - 오경민
        
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        폴리필 방식을 알고계신가요?
        
        크로스 브라우징을 위한 고려사항
        
        크로스 브라우징을 고려해서 개발해본 경험
        
        구형 익스플로러에 크로스 브라우징을 어떻게 해결하실건가요?
        
        오래된 브라우저를 지원해야할 경우 어떻게 구현하실것인가요?
        
19. **React 의 Portal 에 대해서 설명해주세요**
    
    ✅ **답변**
    
    - 방혜찬
        
        React Portal은 컴포넌트의 DOM 계층 구조와 상관없이, DOM의 특정 위치에 렌더링하는 방법입니다.
        부모 컴포넌트의 스타일이나 레이아웃에 영향을 받지 않고, DOM 트리 외부에 컴포넌트를 렌더링할 수 있어 모달이나 툴팁, 드롭다운같은 컴포넌트를 구현할 때 많이 사용합니다.
        
        ---
        
        **추가 질문 2**: Portal을 사용할 때 이벤트 버블링은 어떻게 동작하나요?
        
        **답변**: Portal을 사용하더라도 이벤트 버블링은 원래의 부모 자식 관계에 따라 발생합니다. 즉, Portal을 통해 렌더링된 요소의 이벤트는 DOM 트리의 위치와 상관없이 원래의 부모 요소로 버블링됩니다.
        
        **요약**: "Portal을 사용해도 이벤트 버블링은 원래 부모 자식 관계에 따라 발생합니다."
        
        **추가 질문 3**: Portal을 사용하는 방법 외에 DOM 외부에 컴포넌트를 렌더링하는 다른 방법은 무엇인가요?
        
        **답변**: Portal 외에도 직접 `ReactDOM.render`를 사용하여 특정 DOM 요소에 컴포넌트를 렌더링할 수 있습니다. 그러나 Portal은 더 간결하고 일관된 방법을 제공합니다.
        
        **요약**: "Portal 외에도 `ReactDOM.render`를 사용하여 특정 DOM 요소에 컴포넌트를 렌더링할 수 있지만, Portal이 더 간결하고 일관된 방법을 제공합니다."
        
    - 오경민
        
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        portal 의 사용 예시?
        
        portal 을 사용해 모달을 구현했을 때 장점?
        
        Portal을 사용하면서 이벤트 버블링이 어떻게 처리되나요?
        
        포탈을 사용하지 않고도 모달을 구현할 수 있는데, 포탈을 사용하는 이유는 무엇인가요?
        

🔥 **피드백(17~19)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 이지혜 |  |
    | --- | --- | --- | --- |
    | 좋았던 점 | 각 질문에 대해서 개념설명을 워낙 잘 설명해 주셔서 좋았습니다.
    
    함수형 프로그래밍의 단점에 대한 질문까지 잘 말씀해 주셔서 좋았습니다. | 개념과 주요 특징에 대해 잘 설명해주셨고, 장점도 잘 말씀해주셨습니다.  |  |
    | 개선사항 | 크게 피드백 드릴 내용이 없습니다. 잘해주셨습니다. |  |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 이지혜 |
    | --- | --- | --- |
    | 좋았던 점 | 전체적으로 내용이 간결하고 좋았습니다. | 내용에 대해서는 간결하고 핵심적인 내용으로 잘 말씀해주셨습니다. |
    | 개선사항 | 18, 19. 개념에 관련된 예시도 간단하게만 포함해주시면 좋을 듯 합니다. | 추가질문으로 드린 내용을 처음 답변할때 간단하게 요약하여서 함께 말씀해주셔도 좋을 것 같습니다.  |

---

20. **React 의 에러 바운더리 에 대해서 설명해주세요.**
    
    ✅ **답변**
    
    - 방혜찬
        
        에러바운더리는 React 컴포넌트에서 오류가 발생했을 때, 어플리케이션이 중단되지 않도록 처리해주는 컴포넌트입니다.
        에러 바운더리를 사용하면 하위에 있는 컴포넌트 트리 전체에서 발생한 에러를 처리할 수 있으며, 처리하고 싶은 범위에 따라 여러 에러 바운더리를 계층적으로 설정할 수 있습니다.
        
        에러 바운더리는 클래스 컴포넌트 형태로 구현되며, 내부 메서드를 활용해 에러에 따른 상태값을 설정, Fallback UI 렌더링, 에러 로깅 등의 작업을 설정할 수 있습니다.
        단 이벤트핸들러나 비동기 코드, ssr 과 에러 바운더리 내에서 발생하는 에러들은 잡을수 없어서 따로 처리가 필요합니다.
        
        ---
        
        사용 방법
        
        - getDerivedStateFromError : 하위의 자손 컴포넌트에서 오류가 발생했을 때 호출됩니다. 매개변수로 오류를 전달받고, 갱신된 state 값을 반드시 반환해야 합니다. 렌더링 전에 실행하기 때문에, 딜레이가 걸리는 부가 작업은 더 나중에 실행되는 componentDidCatch 에 작성합니다.
        - componentDidCatch : 자손 컴포넌트에서 오류가 발생했을 때에 호출되며, 2개의 매개변수를 전달받습니다.
            - error : 발생한 오류
            - info : 어떤 컴포넌트가 오류를 발생시켰는지에 대한 정보를 포함한 componentStack 키를 갖고 있는 객체
        
        이벤트핸들러 : try catch 로 처리해야합니다.
        
        비동기 코드 : 후속처리나 try catch 로 처리합니다.
        
        ssr : 서버사이드에서 에러가 발생하는 경우 null 값 등을 반환하고, 브라우저에서 그에 따른 조치를 하도록 코딩합니다.
        
        에러 바운더리 내에서 에러가 발생하는 경우, 상위에 있는 에러 바운더리 중 가장 가까운 에러 바운더리에서 처리됩니다.
        
    - 오경민
        
        React 의 에러 바운더리 에 대해서 설명해주세요.
        에러 바운더리는 하위 컴포넌트 트리의 어디에서든 자바스크립트 에러를 기록하며 깨진 컴포넌트 트리 대신 폴백 UI를 보여주는 React 컴포넌트로 에러 경계는 렌더링 도중 생명주기 메서드 및 그 아래에 있는 전체 트리에서 에러를 잡아냅니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        
21. **Array 와 LinkedList 에 대해서 설명해주세요.**
    
    ✅ **답변**
    
    - 방혜찬
        
        Array 와 LinkedList 는 여러개의 데이터들을 순서대로 저장하는 자료구조입니다.
        Array 는 연속된 메모리 공간에 데이터를 저장해 빠른 접근이 가능하지만 크기 조정과 중간 삽입/삭제가 비효율적입니다.
        Linked List 는 동적으로 크기를 조절할 수 있으며 중간 삽입/삭제가 효율적이지만 접근 속도가 느리고 메모리 사용이 비효율적입니다.
        
        ---
        
        **Array**:
        
        - **구조**: 연속적인 메모리 위치에 요소를 저장하는 데이터 구조입니다.
        - **접근 시간**: O(1) - 인덱스를 사용하여 임의의 요소에 즉시 접근할 수 있습니다.
        - **삽입/삭제 시간**: O(n) - 배열의 중간에 삽입하거나 삭제할 때는 모든 요소를 이동시켜야 합니다.
        - **장점**: 빠른 접근 시간, 공간 효율적
        - **단점**: 크기가 고정되어 있으며, 크기 변경이 어렵고, 중간에 삽입/삭제가 비효율적
        
        **LinkedList**:
        
        - **구조**: 각 요소가 데이터와 다음 요소를 가리키는 포인터를 가지는 노드들로 이루어진 데이터 구조입니다.
        - **접근 시간**: O(n) - 원하는 요소에 접근하기 위해 처음부터 순차적으로 탐색해야 합니다.
        - **삽입/삭제 시간**: O(1) - 노드의 삽입과 삭제가 빠릅니다.
        - **장점**: 동적 크기 조정이 가능, 중간 삽입/삭제가 효율적
        - **단점**: 느린 접근 시간, 추가적인 메모리 사용(포인터 저장)
        
        **추가 질문 1**: 배열과 연결 리스트의 활용 사례를 설명해주세요.
        
        **답변**: 배열은 요소에 빠르게 접근해야 하는 상황에서, 연결 리스트는 빈번한 삽입/삭제가 필요한 상황에서 유용합니다.
        
        **요약**: "배열은 빠른 접근이 필요할 때, 연결 리스트는 빈번한 삽입/삭제가 필요할 때 유용합니다."
        
        **추가 질문 2**: 연결 리스트의 종류에는 어떤 것들이 있나요?
        
        **답변**: 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트가 있습니다.
        
        **요약**: "단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트가 있습니다."
        
        **추가 질문 3**: 배열의 크기를 동적으로 변경할 수 없는 이유는 무엇인가요?
        
        **답변**: 배열은 연속된 메모리 공간에 저장되므로 크기를 변경하면 새로운 메모리 공간을 할당하고 기존 요소를 복사해야 합니다.
        
        **요약**: "배열은 연속된 메모리 공간에 저장되므로 크기를 변경하면 새로운 메모리 공간을 할당하고 기존 요소를 복사해야 합니다."
        
    - 오경민
        
        배열
        
        연속된 메모리 공간에 데이터를 저장합니다.
        인덱스를 사용하여 원소에 빠르게 접근할 수 있습니다.
        
        고정된 크기를 가지며, 크기 변경이 어렵습니다. 미리 할당된 메모리 크기를 초과하면 새로운 메모리 공간을 할당하고 데이터를 복사해야 합니다.
        원소를 삽입하거나 삭제할 때, 원소들을 이동시켜야 하므로 시간이 오래 걸릴 수 있습니다.
        
        링크드 리스트
        
        각 노드가 데이터와 다음 노드에 대한 참조 포인터를 포함하며, 노드들이 연속되지 않은 메모리 공간에 저장됩니다.
        원소에 접근하기 위해서는 리스트를 순차적으로 탐색해야 하며, On의 시간 복잡도를 가집니다.
        크기 변경이 쉽습니다. 새 노드를 동적으로 할당하거나 제거함으로써 리스트의 크기를 변경할 수 있습니다.
        원소를 삽입하거나 삭제할 때, 포인터를 업데이트만 하면 되므로 상대적으로 빠른 시간에 처리할 수 있습니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        
22. **번들러와 트랜스파일러에 대해서 설명해주세요.**
    
    ✅ **답변**
    
    - 방혜찬
        
        번들러는 다양한 프레임워크로 작성된 코드를 브라우저에서 사용할 수 있는 순수 HTML, CSS, JS 로 변환해주고, 그 과정에서 여러 개의 리소스 파일들을 하나 또는 여러 개의 파일로 묶어서 배포에 최적화 시켜주는 도구입니다.
        대표적 번들러들은 Webpack, Parcel, Rollup 등이 있습니다.
        또한 Webpack 같은 번들러는 모듈 병합, 코드 스플리팅, 트리 쉐이킹 등의 기능을 자체적으로 제공하기 때문에 배포 최적화가 가능합니다.
        
        트랜스 파일러는 최신 자바스크립트 문법으로 작성된 코드를 실행할 수 없는 구형 브라우저를 고려하여 이전 버전의 자바스크립트 코드로 변환해주는 도구입니다.
        또한 폴리필을 추가하여 호환성을 유지하고, 소스맵 생성 등의 기능을 통해 빌드파일의 디버깅을 도와줍니다.
        대표적인 트랜스 파일러는 Babel 이 있습니다.
        
        ---
        
        번들러는 모듈 병합, 코드 스플리팅, 트리 쉐이킹 등의 기능 제공.
        코드 스플리팅은 애플리케이션을 여러 번들로 분리하여 필요한 부분만 로드하게 하여 초기 로딩 시간을 줄이는 기법입니다.
        트리 쉐이킹은 사용되지 않는 코드를 제거하여 번들 크기를 줄이는 최적화 기법입니다.
        소스맵은 배포용으로 빌드한 파일과 원본 파일을 서로 연결시켜주는 기능. 소스 맵을 이용해 배포용 파일의 특정 부분이 원본 소스의 어떤 부분인지 확인 가능
        
    - 오경민
        
        번들러는 여러 개의 파일과 모듈을 하나의 파일이나 몇 개의 파일로 묶어주는 도구입니다. 주로 웹 애플리케이션에서 사용하는 다양한 자바스크립트, CSS, 이미지 파일 등을 하나로 묶어서 배포하기 위해 사용됩니다. 번들러는 웹 애플리케이션의 성능을 최적화하고, 의존성 관리를 쉽게 해줍니다.
        
        트랜스파일러는 한 언어로 작성된 코드를 다른 언어로 변환하는 도구입니다. 주로 최신 자바스크립트(ES6 이상) 문법을 구형 브라우저에서도 동작할 수 있도록 ES5 코드로 변환하거나, 타입스크립트 코드를 자바스크립트 코드로 변환하는 데 사용됩니다.
        
    - 이지혜
        
        
    - **❓ 꼬리질문**
        
        

🔥 **피드백(20~22)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 이지혜 |  |
    | --- | --- | --- | --- |
    | 좋았던 점 | 개념에 대한 설명과, 꼬리질문까지 잘 대답해 주셔서 좋았습니다. |  |  |
    | 개선사항 | LinkedList를 사용하는 알고리즘에 대해서 간단하게 어떤게 있는지, Vite와 webpack을 비교했을 때, Vite가 어떤 장점이 있는지 조금 더 알아두시면 더 좋을 것 같습니다. |  |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 이지혜 |
    | --- | --- | --- |
    | 좋았던 점 | 답변 내용에 핵심적인 내용은 다 포함해주셔서 좋았습니다. |  |
    | 개선사항 | 20. 에러 바운더리 구현에 사용되는 메서드들의 실행 시점도 같이 설명해주시면 더 좋을 것 같습니다.
    22. 대표적인 번들러나 트랜스파일러 도구들이 제공하는 부가적인 기능들도 같이 알아두시면 좋지않을까요? (아닐수도…) |  |

---

## 생략한 원본 문제

---

1. 브라우저 렌더링 과정에 대해 아는 만큼 설명해주실 수 있을까요? 예를 들어 화면에서 DOM이 어떻게 결정되고, CSS는 어떻게 입혀지는지 등을 언급해주시면 좋습니다.
    
    ✅ **답변**
    
    - 방혜찬
        
        
    - 오경민
        
        
    - 김섭찬
        
        
2. 이미지 최적화에 대해 설명해주시고 방법에 대해 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        
    - 오경민
        
        
    - 김섭찬
        
        
3. 프론트엔드 개발 시 개발자 도구를 활용한 경험이 있다면 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        
    - 오경민
        
        
    - 김섭찬
        
        

🔥 **피드백(34~36)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
    

---

1. REST란 무엇인지, 구성요소, 특징과 함께 얘기해주세요
    
    ✅ **답변**
    
    - 방혜찬
        
        
    - 오경민
        
        
    - 김섭찬
        
        
2. Array, LinkedList에 대해 설명해주시고 각각 어떻게 사용하는지 말씀해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        
    - 오경민
        
        
    - 김섭찬
        
        
3. 쓰로틀링과 디바운싱의 개념과 사용하는 이유에 대해서 설명해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        
    - 오경민
        
        
    - 김섭찬
        
        

🔥 **피드백(37~39)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
    

---

1. AWS S3를 사용하는 이유와 사용 경험에 대해서 답변해주세요.
    
    ✅ **답변**
    
    - 방혜찬
        
        
    - 오경민
        
        
    - 김섭찬
        
        
2. Web Vital을 개선할 수 있는 방안에 대해 설명해주실 수 있을까요? 예를 들어 LCP, CLS, FID 각각의 개념, 진단법, 각 지표 개선에 효과적인 조치 방안을 언급해주시면 좋습니다.
    
    ✅ **답변**
    
    - 방혜찬
        
        
    - 오경민
        
        
    - 김섭찬
        
        

🔥 **피드백(40~41)**

- 방혜찬
    
    
    | 면접관 | 오경민 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
- 오경민
    
    
    | 면접관 | 방혜찬 | 김섭찬 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
- 김섭찬
    
    
    | 면접관 | 방혜찬 | 오경민 |
    | --- | --- | --- |
    | 좋았던 점 |  |  |
    | 개선사항 |  |  |
